<link rel="stylesheet" href="../../..//default.css">
<script src="../../..//highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><pre><code class='java'>
<a href="https://github.com/HDI-Project/MLBlocks/blob/master/tests/test_mlpipeline.py#L1161">GitHubLink</a>


<a href="https://github.com/maldil/MLBlocks/blob/master/tests/test_mlpipeline.py#L1161">GitMyHubLink</a>

&#47&#47 -*- coding: utf-8 -*-

from collections import OrderedDict
from unittest import TestCase
from unittest.mock import MagicMock, call, patch

import pytest

from mlblocks.mlblock import MLBlock
from mlblocks.mlpipeline import MLPipeline


def get_mlblock_mock(*args, **kwargs):
    return MagicMock(autospec=MLBlock)


class TestMLPipline(TestCase):

    @patch(&quotmlblocks.mlpipeline.LOGGER&quot)
    @patch(&quotmlblocks.mlpipeline.MLBlock&quot)
    def test___init__(self, mlblock_mock, logger_mock):
        blocks = [
            get_mlblock_mock(),
            get_mlblock_mock(),
            get_mlblock_mock(),
            get_mlblock_mock()
        ]
        last_block = blocks[-1]
        last_block.produce_output = [
            {
                &quotname&quot: &quoty&quot,
                &quottype&quot: &quotarray&quot
            }
        ]
        mlblock_mock.side_effect = blocks

        primitives = [
            &quota.primitive.Name&quot,
            &quota.primitive.Name&quot,
            &quotanother.primitive.Name&quot,
            &quotanother.primitive.Name&quot,
        ]
        expected_primitives = primitives.copy()

        init_params = {
            &quota.primitive.Name&quot: {
                &quotan_argument&quot: &quotvalue&quot,
            },
            &quotanother.primitive.Name&#47&#472&quot: {
                &quotanother&quot: &quotargument_value&quot,
            }
        }
        expected_init_params = init_params.copy()
        input_names = {
            &quotanother.primitive.Name&#47&#471&quot: {
                &quota_name&quot: &quotanother_name&quot,
            }
        }
        expected_input_names = input_names.copy()

        mlpipeline = MLPipeline(
            primitives=primitives,
            init_params=init_params,
            input_names=input_names
        )

        assert mlpipeline.primitives == expected_primitives
        assert mlpipeline.init_params == expected_init_params
        assert mlpipeline.blocks == OrderedDict((
            (&quota.primitive.Name&#47&#471&quot, blocks[0]),
            (&quota.primitive.Name&#47&#472&quot, blocks[1]),
            (&quotanother.primitive.Name&#47&#471&quot, blocks[2]),
            (&quotanother.primitive.Name&#47&#472&quot, blocks[3])
        ))
        assert mlpipeline.input_names == expected_input_names
        assert mlpipeline.output_names == dict()
        assert mlpipeline._tunable_hyperparameters == {
            &quota.primitive.Name&#47&#471&quot: blocks[0].get_tunable_hyperparameters.return_value,
            &quota.primitive.Name&#47&#472&quot: blocks[1].get_tunable_hyperparameters.return_value,
            &quotanother.primitive.Name&#47&#471&quot: blocks[2].get_tunable_hyperparameters.return_value,
            &quotanother.primitive.Name&#47&#472&quot: blocks[3].get_tunable_hyperparameters.return_value
        }
        assert mlpipeline.outputs == {
            &quotdefault&quot: [
                {
                    &quotname&quot: &quoty&quot,
                    &quottype&quot: &quotarray&quot,
                    &quotvariable&quot: &quotanother.primitive.Name&#47&#472.y&quot
                }
            ]
        }
        assert mlpipeline.verbose

        expected_calls = [
            call(&quota.primitive.Name&quot, an_argument=&quotvalue&quot),
            call(&quota.primitive.Name&quot, an_argument=&quotvalue&quot),
            call(&quotanother.primitive.Name&quot),
            call(&quotanother.primitive.Name&quot, another=&quotargument_value&quot),
        ]
        assert mlblock_mock.call_args_list == expected_calls

        logger_mock.warning.assert_called_once_with(
            &quotNon-numbered init_params are being used for more than one block %s.&quot,
            &quota.primitive.Name&quot
        )

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_tunable_hyperparameters(self):
        mlpipeline = MLPipeline([&quota_primitive&quot])
        tunable = dict()
        mlpipeline._tunable_hyperparameters = tunable

        returned = mlpipeline.get_tunable_hyperparameters()

        assert returned == tunable
        assert returned is not tunable

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_tunable_hyperparameters_flat(self):
        mlpipeline = MLPipeline([&quota_primitive&quot])
        mlpipeline._tunable_hyperparameters = {
            &quotblock_1&quot: {
                &quothp_1&quot: {
                    &quottype&quot: &quotint&quot,
                    &quotrange&quot: [
                        1,
                        10
                    ],
                }
            },
            &quotblock_2&quot: {
                &quothp_1&quot: {
                    &quottype&quot: &quotstr&quot,
                    &quotdefault&quot: &quota&quot,
                    &quotvalues&quot: [
                        &quota&quot,
                        &quotb&quot,
                        &quotc&quot
                    ],
                },
                &quothp_2&quot: {
                    &quottype&quot: &quotbool&quot,
                    &quotdefault&quot: True,
                }
            }
        }

        returned = mlpipeline.get_tunable_hyperparameters(flat=True)

        expected = {
            (&quotblock_1&quot, &quothp_1&quot): {
                &quottype&quot: &quotint&quot,
                &quotrange&quot: [
                    1,
                    10
                ],
            },
            (&quotblock_2&quot, &quothp_1&quot): {
                &quottype&quot: &quotstr&quot,
                &quotdefault&quot: &quota&quot,
                &quotvalues&quot: [
                    &quota&quot,
                    &quotb&quot,
                    &quotc&quot
                ],
            },
            (&quotblock_2&quot, &quothp_2&quot): {
                &quottype&quot: &quotbool&quot,
                &quotdefault&quot: True,
            }
        }
        assert returned == expected

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_hyperparameters(self):
        block_1 = get_mlblock_mock()
        block_1.get_hyperparameters.return_value = {
            &quota&quot: &quota&quot
        }
        block_2 = get_mlblock_mock()
        block_2.get_hyperparameters.return_value = {
            &quotb&quot: &quotb&quot,
            &quotc&quot: &quotc&quot,
        }
        blocks = OrderedDict((
            (&quota.primitive.Name&#47&#471&quot, block_1),
            (&quota.primitive.Name&#47&#472&quot, block_2),
        ))
        mlpipeline = MLPipeline([&quota_primitive&quot])
        mlpipeline.blocks = blocks

        hyperparameters = mlpipeline.get_hyperparameters()

        assert hyperparameters == {
            &quota.primitive.Name&#47&#471&quot: {
                &quota&quot: &quota&quot,
            },
            &quota.primitive.Name&#47&#472&quot: {
                &quotb&quot: &quotb&quot,
                &quotc&quot: &quotc&quot,
            },
        }
        block_1.get_hyperparameters.assert_called_once_with()
        block_2.get_hyperparameters.assert_called_once_with()

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_hyperparameters_flat(self):
        block_1 = get_mlblock_mock()
        block_1.get_hyperparameters.return_value = {
            &quota&quot: &quota&quot
        }
        block_2 = get_mlblock_mock()
        block_2.get_hyperparameters.return_value = {
            &quotb&quot: &quotb&quot,
            &quotc&quot: &quotc&quot,
        }
        blocks = OrderedDict((
            (&quota.primitive.Name&#47&#471&quot, block_1),
            (&quota.primitive.Name&#47&#472&quot, block_2),
        ))
        mlpipeline = MLPipeline([&quota_primitive&quot])
        mlpipeline.blocks = blocks

        hyperparameters = mlpipeline.get_hyperparameters(flat=True)

        assert hyperparameters == {
            (&quota.primitive.Name&#47&#471&quot, &quota&quot): &quota&quot,
            (&quota.primitive.Name&#47&#472&quot, &quotb&quot): &quotb&quot,
            (&quota.primitive.Name&#47&#472&quot, &quotc&quot): &quotc&quot,
        }
        block_1.get_hyperparameters.assert_called_once_with()
        block_2.get_hyperparameters.assert_called_once_with()

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_set_hyperparameters(self):
        block_1 = get_mlblock_mock()
        block_2 = get_mlblock_mock()
        blocks = OrderedDict((
            (&quota.primitive.Name&#47&#471&quot, block_1),
            (&quota.primitive.Name&#47&#472&quot, block_2),
        ))
        mlpipeline = MLPipeline([&quota_primitive&quot])
        mlpipeline.blocks = blocks

        hyperparameters = {
            &quota.primitive.Name&#47&#472&quot: {
                &quotsome&quot: &quotarg&quot
            }
        }
        mlpipeline.set_hyperparameters(hyperparameters)

        block_1.set_hyperparameters.assert_not_called()
        block_2.set_hyperparameters.assert_called_once_with({&quotsome&quot: &quotarg&quot})

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_set_hyperparameters_flat(self):
        block_1 = get_mlblock_mock()
        block_2 = get_mlblock_mock()
        blocks = OrderedDict((
            (&quota.primitive.Name&#47&#471&quot, block_1),
            (&quota.primitive.Name&#47&#472&quot, block_2),
        ))
        mlpipeline = MLPipeline([&quota_primitive&quot])
        mlpipeline.blocks = blocks

        hyperparameters = {
            (&quota.primitive.Name&#47&#472&quot, &quotsome&quot): &quotarg&quot
        }
        mlpipeline.set_hyperparameters(hyperparameters)

        block_1.set_hyperparameters.assert_not_called()
        block_2.set_hyperparameters.assert_called_once_with({&quotsome&quot: &quotarg&quot})

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test__get_block_args(self):
        input_names = {
            &quota_block&quot: {
                &quotarg_3&quot: &quotarg_3_alt&quot
            }
        }
        pipeline = MLPipeline([&quota_primitive&quot], input_names=input_names)

        block_args = [
            {
                &quotname&quot: &quotarg_1&quot,
            },
            {
                &quotname&quot: &quotarg_2&quot,
                &quotdefault&quot: &quotarg_2_value&quot
            },
            {
                &quotname&quot: &quotarg_3&quot,
            },
            {
                &quotname&quot: &quotarg_4&quot,
                &quotrequired&quot: False
            },
        ]
        context = {
            &quotarg_1&quot: &quotarg_1_value&quot,
            &quotarg_3_alt&quot: &quotarg_3_value&quot
        }

        args = pipeline._get_block_args(&quota_block&quot, block_args, context)

        expected = {
            &quotarg_1&quot: &quotarg_1_value&quot,
            &quotarg_3&quot: &quotarg_3_value&quot,
        }
        assert args == expected

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test__get_outputs_no_outputs(self):
        self_ = MagicMock(autospec=MLPipeline)

        self_._last_block_name = &quotlast_block&quot
        self_._get_block_outputs.return_value = [&quotsome&quot, &quotoutputs&quot]

        pipeline = dict()
        outputs = None
        returned = MLPipeline._get_outputs(self_, pipeline, outputs)

        expected = {
            &quotdefault&quot: [&quotsome&quot, &quotoutputs&quot]
        }
        assert returned == expected

        self_._get_block_outputs.assert_called_once_with(&quotlast_block&quot)

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test__get_outputs_defaults(self):
        self_ = MagicMock(autospec=MLPipeline)

        pipeline = dict()
        outputs = {
            &quotdefault&quot: [&quotsome&quot, &quotoutputs&quot]
        }
        returned = MLPipeline._get_outputs(self_, pipeline, outputs)

        expected = {
            &quotdefault&quot: [&quotsome&quot, &quotoutputs&quot]
        }
        assert returned == expected
        self_._get_block_outputs.assert_not_called()

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test__get_outputs_additional(self):
        self_ = MagicMock(autospec=MLPipeline)

        pipeline = {
            &quotoutputs&quot: {
                &quotdefault&quot: [&quotsome&quot, &quotoutputs&quot],
                &quotadditional&quot: [&quotother&quot, &quotoutputs&quot]
            }
        }
        outputs = None
        returned = MLPipeline._get_outputs(self_, pipeline, outputs)

        expected = {
            &quotdefault&quot: [&quotsome&quot, &quotoutputs&quot],
            &quotadditional&quot: [&quotother&quot, &quotoutputs&quot]
        }
        assert returned == expected
        self_._get_block_outputs.assert_not_called()

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_outputs_str_named(self):
        outputs = {
            &quotdefault&quot: [
                {
                    &quotname&quot: &quota_name&quot,
                    &quotvariable&quot: &quota_variable&quot,
                    &quottype&quot: &quota_type&quot,
                }
            ],
            &quotdebug&quot: [
                {
                    &quotname&quot: &quotanother_name&quot,
                    &quotvariable&quot: &quotanother_variable&quot,
                }
            ]
        }
        pipeline = MLPipeline([&quota_primitive&quot, &quotanother_primitive&quot], outputs=outputs)

        returned = pipeline.get_outputs(&quotdebug&quot)

        expected = [
            {
                &quotname&quot: &quotanother_name&quot,
                &quotvariable&quot: &quotanother_variable&quot,
            }
        ]
        assert returned == expected

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_outputs_str_variable(self):
        pipeline = MLPipeline([&quota_primitive&quot, &quotanother_primitive&quot])
        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_output = [
            {
                &quotname&quot: &quotoutput&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]

        returned = pipeline.get_outputs(&quota_primitive&#47&#471.output&quot)

        expected = [
            {
                &quotname&quot: &quotoutput&quot,
                &quottype&quot: &quotwhatever&quot,
                &quotvariable&quot: &quota_primitive&#47&#471.output&quot
            }
        ]
        assert returned == expected

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_outputs_str_block(self):
        pipeline = MLPipeline([&quota_primitive&quot, &quotanother_primitive&quot])

        returned = pipeline.get_outputs(&quota_primitive&#47&#471&quot)

        expected = [
            {
                &quotname&quot: &quota_primitive&#47&#471&quot,
                &quotvariable&quot: &quota_primitive&#47&#471&quot,
            }
        ]
        assert returned == expected

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_outputs_int(self):
        pipeline = MLPipeline([&quota_primitive&quot, &quotanother_primitive&quot])

        returned = pipeline.get_outputs(-1)

        expected = [
            {
                &quotname&quot: &quotanother_primitive&#47&#471&quot,
                &quotvariable&quot: &quotanother_primitive&#47&#471&quot,
            }
        ]
        assert returned == expected

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_outputs_combination(self):
        outputs = {
            &quotdefault&quot: [
                {
                    &quotname&quot: &quota_name&quot,
                    &quotvariable&quot: &quota_variable&quot,
                    &quottype&quot: &quota_type&quot,
                }
            ],
            &quotdebug&quot: [
                {
                    &quotname&quot: &quotanother_name&quot,
                    &quotvariable&quot: &quotanother_variable&quot,
                }
            ]
        }
        pipeline = MLPipeline([&quota_primitive&quot, &quotanother_primitive&quot], outputs=outputs)
        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_output = [
            {
                &quotname&quot: &quotoutput&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]
        pipeline.blocks[&quotanother_primitive&#47&#471&quot].produce_output = [
            {
                &quotname&quot: &quotsomething&quot,
            }
        ]

        returned = pipeline.get_outputs([&quotdefault&quot, &quotdebug&quot, -1, &quota_primitive&#47&#471.output&quot])

        expected = [
            {
                &quotname&quot: &quota_name&quot,
                &quotvariable&quot: &quota_variable&quot,
                &quottype&quot: &quota_type&quot
            },
            {
                &quotname&quot: &quotanother_name&quot,
                &quotvariable&quot: &quotanother_variable&quot,
            },
            {
                &quotname&quot: &quotanother_primitive&#47&#471&quot,
                &quotvariable&quot: &quotanother_primitive&#47&#471&quot,
            },
            {
                &quotname&quot: &quotoutput&quot,
                &quottype&quot: &quotwhatever&quot,
                &quotvariable&quot: &quota_primitive&#47&#471.output&quot
            }
        ]
        assert returned == expected

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_outputs_invalid(self):
        pipeline = MLPipeline([&quota_primitive&quot])

        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_output = [
            {
                &quotname&quot: &quotoutput&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]

        with pytest.raises(ValueError):
            pipeline.get_outputs(&quota_primitive&#47&#471.invalid&quot)

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_output_names(self):
        outputs = {
            &quotdefault&quot: [
                {
                    &quotname&quot: &quota_name&quot,
                    &quotvariable&quot: &quota_variable&quot,
                    &quottype&quot: &quota_type&quot,
                }
            ]
        }
        pipeline = MLPipeline([&quota_primitive&quot], outputs=outputs)

        names = pipeline.get_output_names()

        assert names == [&quota_name&quot]

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_output_variables(self):
        outputs = {
            &quotdefault&quot: [
                {
                    &quotname&quot: &quota_name&quot,
                    &quotvariable&quot: &quota_variable&quot,
                    &quottype&quot: &quota_type&quot,
                }
            ]
        }
        pipeline = MLPipeline([&quota_primitive&quot], outputs=outputs)

        names = pipeline.get_output_variables()

        assert names == [&quota_variable&quot]

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test__get_block_variables_is_dict(self):
        pipeline = MLPipeline([&quota_primitive&quot])
        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_outputs = [
            {
                &quotname&quot: &quotoutput&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]

        outputs = pipeline._get_block_variables(
            &quota_primitive&#47&#471&quot,
            &quotproduce_outputs&quot,
            {&quotoutput&quot: &quotname_output&quot}
        )

        expected = {
            &quotname_output&quot: {
                &quotname&quot: &quotoutput&quot,
                &quottype&quot: &quotwhatever&quot,
            }
        }
        assert outputs == expected

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test__get_block_variables_is_str(self):
        pipeline = MLPipeline([&quota_primitive&quot])
        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_outputs = &quotget_produce_outputs&quot
        pipeline.blocks[&quota_primitive&#47&#471&quot].instance.get_produce_outputs.return_value = [
            {
                &quotname&quot: &quotoutput_from_function&quot,
                &quottype&quot: &quottest&quot
            }

        ]

        outputs = pipeline._get_block_variables(
            &quota_primitive&#47&#471&quot,
            &quotproduce_outputs&quot,
            {&quotoutput&quot: &quotname_output&quot}
        )

        expected = {
            &quotoutput_from_function&quot: {
                &quotname&quot: &quotoutput_from_function&quot,
                &quottype&quot: &quottest&quot,
            }
        }
        assert outputs == expected
        pipeline.blocks[&quota_primitive&#47&#471&quot].instance.get_produce_outputs.assert_called_once_with()

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_inputs_fit(self):
        pipeline = MLPipeline([&quota_primitive&quot, &quotanother_primitive&quot])
        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_args = [
            {
                &quotname&quot: &quotinput&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]
        pipeline.blocks[&quota_primitive&#47&#471&quot].fit_args = [
            {
                &quotname&quot: &quotfit_input&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]
        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_output = [
            {
                &quotname&quot: &quotoutput&quot,
                &quottype&quot: &quotanother_whatever&quot
            }
        ]
        pipeline.blocks[&quotanother_primitive&#47&#471&quot].produce_args = [
            {
                &quotname&quot: &quotoutput&quot,
                &quottype&quot: &quotanother_whatever&quot
            },
            {
                &quotname&quot: &quotanother_input&quot,
                &quottype&quot: &quotanother_whatever&quot
            }
        ]

        inputs = pipeline.get_inputs()

        expected = {
            &quotinput&quot: {
                &quotname&quot: &quotinput&quot,
                &quottype&quot: &quotwhatever&quot,
            },
            &quotfit_input&quot: {
                &quotname&quot: &quotfit_input&quot,
                &quottype&quot: &quotwhatever&quot,
            },
            &quotanother_input&quot: {
                &quotname&quot: &quotanother_input&quot,
                &quottype&quot: &quotanother_whatever&quot,
            }
        }
        assert inputs == expected

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_inputs_no_fit(self):
        pipeline = MLPipeline([&quota_primitive&quot, &quotanother_primitive&quot])
        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_args = [
            {
                &quotname&quot: &quotinput&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]
        pipeline.blocks[&quota_primitive&#47&#471&quot].fit_args = [
            {
                &quotname&quot: &quotfit_input&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]
        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_output = [
            {
                &quotname&quot: &quotoutput&quot,
                &quottype&quot: &quotanother_whatever&quot
            }
        ]
        pipeline.blocks[&quotanother_primitive&#47&#471&quot].produce_args = [
            {
                &quotname&quot: &quotoutput&quot,
                &quottype&quot: &quotanother_whatever&quot
            },
            {
                &quotname&quot: &quotanother_input&quot,
                &quottype&quot: &quotanother_whatever&quot
            }
        ]

        inputs = pipeline.get_inputs(fit=False)

        expected = {
            &quotinput&quot: {
                &quotname&quot: &quotinput&quot,
                &quottype&quot: &quotwhatever&quot,
            },
            &quotanother_input&quot: {
                &quotname&quot: &quotanother_input&quot,
                &quottype&quot: &quotanother_whatever&quot,
            }
        }
        assert inputs == expected

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_fit_args(self):
        pipeline = MLPipeline([&quota_primitive&quot])
        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_args = [
            {
                &quotname&quot: &quotinput&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]
        pipeline.blocks[&quota_primitive&#47&#471&quot].fit_args = [
            {
                &quotname&quot: &quotfit_input&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]
        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_output = [
            {
                &quotname&quot: &quotoutput&quot,
                &quottype&quot: &quotanother_whatever&quot
            }
        ]

        outputs = pipeline.get_fit_args()

        expected = [
            {
                &quotname&quot: &quotinput&quot,
                &quottype&quot: &quotwhatever&quot
            },
            {
                &quotname&quot: &quotfit_input&quot,
                &quottype&quot: &quotwhatever&quot,
            }
        ]
        assert outputs == expected

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_predict_args(self):
        pipeline = MLPipeline([&quota_primitive&quot])
        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_args = [
            {
                &quotname&quot: &quotinput&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]
        pipeline.blocks[&quota_primitive&#47&#471&quot].fit_args = [
            {
                &quotname&quot: &quotfit_input&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]
        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_output = [
            {
                &quotname&quot: &quotoutput&quot,
                &quottype&quot: &quotanother_whatever&quot
            }
        ]
        outputs = pipeline.get_predict_args()

        expected = [
            {
                &quotname&quot: &quotinput&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]
        assert outputs == expected

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_fit_pending_all_primitives(self):
        block_1 = get_mlblock_mock()
        block_2 = get_mlblock_mock()
        blocks = OrderedDict((
            (&quota.primitive.Name&#47&#471&quot, block_1),
            (&quota.primitive.Name&#47&#472&quot, block_2),
        ))

        self_ = MagicMock(autospec=MLPipeline)
        self_.blocks = blocks
        self_._last_fit_block = &quota.primitive.Name&#47&#472&quot

        MLPipeline.fit(self_)

        expected = [
            call(&quota.primitive.Name&#47&#471&quot),
            call(&quota.primitive.Name&#47&#472&quot)
        ]
        self_._fit_block.call_args_list = expected

        expected = [
            call(&quota.primitive.Name&#47&#471&quot),
        ]
        self_._produce_block.call_args_list = expected

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_fit_pending_one_primitive(self):
        block_1 = get_mlblock_mock()
        block_2 = get_mlblock_mock()
        blocks = OrderedDict((
            (&quota.primitive.Name&#47&#471&quot, block_1),
            (&quota.primitive.Name&#47&#472&quot, block_2),
        ))

        self_ = MagicMock(autospec=MLPipeline)
        self_.blocks = blocks
        self_._last_fit_block = &quota.primitive.Name&#47&#471&quot

        MLPipeline.fit(self_)

        expected = [
            call(&quota.primitive.Name&#47&#471&quot),
        ]
        self_._fit_block.call_args_list = expected

        assert not self_._produce_block.called

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_fit_no_debug(self):
        mlpipeline = MLPipeline([&quota_primitive&quot])
        mlpipeline.blocks[&quota_primitive&#47&#471&quot].fit_args = [
            {
                &quotname&quot: &quotfit_input&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]

        returned = mlpipeline.fit(debug=False)

        assert returned is None

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_fit_debug_bool(self):
        mlpipeline = MLPipeline([&quota_primitive&quot])
        mlpipeline.blocks[&quota_primitive&#47&#471&quot].fit_args = [
            {
                &quotname&quot: &quotfit_input&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]

        expected_return = dict()
        expected_return[&quotdebug&quot] = &quottmio&quot
        expected_return[&quotfit&quot] = {
            &quota_primitive&#47&#471&quot: {
                &quottime&quot: 0,
                &quotinput&quot: {
                    &quotwhatever&quot
                },
                &quotmemory&quot: 0,
            }
        }

        returned = mlpipeline.fit(debug=True)

        assert isinstance(returned, dict)
        assert set(returned.keys()) == set(expected_return.keys())  &#47&#47 fit / produce
        assert set(returned[&quotfit&quot].keys()) == set(expected_return[&quotfit&quot].keys())  &#47&#47 block name

        for block_name, dictionary in expected_return[&quotfit&quot].items():
            assert set(returned[&quotfit&quot][block_name].keys()) == set(dictionary.keys())

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_fit_debug_str(self):
        mlpipeline = MLPipeline([&quota_primitive&quot])
        mlpipeline.blocks[&quota_primitive&#47&#471&quot].fit_args = [
            {
                &quotname&quot: &quotfit_input&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]

        expected_return = dict()
        expected_return[&quotdebug&quot] = &quottm&quot
        expected_return[&quotfit&quot] = {
            &quota_primitive&#47&#471&quot: {
                &quottime&quot: 0,
                &quotmemory&quot: 0,
            }
        }

        returned = mlpipeline.fit(debug=&quottm&quot)

        assert isinstance(returned, dict)
        assert set(returned.keys()) == set(expected_return.keys())  &#47&#47 fit / produce
        assert set(returned[&quotfit&quot].keys()) == set(expected_return[&quotfit&quot].keys())  &#47&#47 block name

        for block_name, dictionary in expected_return[&quotfit&quot].items():
            assert set(returned[&quotfit&quot][block_name].keys()) == set(dictionary.keys())

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_fit_produce_debug(self):
        outputs = {
            &quotdefault&quot: [
                {
                    &quotname&quot: &quota_name&quot,
                    &quotvariable&quot: &quota_primitive&#47&#471.a_variable&quot,
                    &quottype&quot: &quota_type&quot,
                }
            ]
        }
        mlpipeline = MLPipeline([&quota_primitive&quot], outputs=outputs)
        mlpipeline.blocks[&quota_primitive&#47&#471&quot].fit_args = [
            {
                &quotname&quot: &quotfit_input&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]

        mlpipeline.blocks[&quota_primitive&#47&#471&quot].produce_args = [
            {
                &quotname&quot: &quotinput&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]

        mlpipeline.blocks[&quota_primitive&#47&#471&quot].produce_output = [
            {
                &quotname&quot: &quota_name&quot,
                &quottype&quot: &quota_type&quot
            }
        ]

        expected_return = dict()
        expected_return[&quotdebug&quot] = &quottmio&quot
        expected_return[&quotfit&quot] = {
            &quota_primitive&#47&#471&quot: {
                &quottime&quot: 0,
                &quotinput&quot: {
                    &quotwhatever&quot
                },
                &quotmemory&quot: 0,
            }
        }
        expected_return[&quotproduce&quot] = {
            &quota_primitive&#47&#471&quot: {
                &quottime&quot: 0,
                &quotinput&quot: {
                    &quotwhatever&quot
                },
                &quotoutput&quot: {
                    &quotwhatever&quot
                },
                &quotmemory&quot: 0,
            }
        }

        returned, debug_returned = mlpipeline.fit(output_=&quotdefault&quot, debug=True)

        assert len([returned]) == len(outputs[&quotdefault&quot])
        assert isinstance(debug_returned, dict)
        assert set(debug_returned.keys()) == set(expected_return.keys())  &#47&#47 fit / produce
        assert set(debug_returned[&quotfit&quot].keys()) == set(expected_return[&quotfit&quot].keys())
        assert set(debug_returned[&quotproduce&quot].keys()) == set(expected_return[&quotproduce&quot].keys())

        for block_name, dictionary in expected_return[&quotfit&quot].items():
            assert set(debug_returned[&quotfit&quot][block_name].keys()) == set(dictionary.keys())

        for block_name, dictionary in expected_return[&quotproduce&quot].items():
            assert set(debug_returned[&quotproduce&quot][block_name].keys()) == set(dictionary.keys())

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_fit_produce_debug_str(self):
        outputs = {
            &quotdefault&quot: [
                {
                    &quotname&quot: &quota_name&quot,
                    &quotvariable&quot: &quota_primitive&#47&#471.a_variable&quot,
                    &quottype&quot: &quota_type&quot,
                }
            ]
        }
        mlpipeline = MLPipeline([&quota_primitive&quot], outputs=outputs)
        mlpipeline.blocks[&quota_primitive&#47&#471&quot].fit_args = [
            {
                &quotname&quot: &quotfit_input&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]

        mlpipeline.blocks[&quota_primitive&#47&#471&quot].produce_args = [
            {
                &quotname&quot: &quotinput&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]

        mlpipeline.blocks[&quota_primitive&#47&#471&quot].produce_output = [
            {
                &quotname&quot: &quota_name&quot,
                &quottype&quot: &quota_type&quot
            }
        ]

        expected_return = dict()
        expected_return[&quotdebug&quot] = &quottm&quot
        expected_return[&quotfit&quot] = {
            &quota_primitive&#47&#471&quot: {
                &quottime&quot: 0,
                &quotmemory&quot: 0,
            }
        }
        expected_return[&quotproduce&quot] = {
            &quota_primitive&#47&#471&quot: {
                &quottime&quot: 0,
                &quotmemory&quot: 0,
            }
        }

        returned, debug_returned = mlpipeline.fit(output_=&quotdefault&quot, debug=&quottm&quot)

        assert len([returned]) == len(outputs[&quotdefault&quot])
        assert isinstance(debug_returned, dict)
        assert set(debug_returned.keys()) == set(expected_return.keys())  &#47&#47 fit / produce
        assert set(debug_returned[&quotfit&quot].keys()) == set(expected_return[&quotfit&quot].keys())
        assert set(debug_returned[&quotproduce&quot].keys()) == set(expected_return[&quotproduce&quot].keys())

        for block_name, dictionary in expected_return[&quotfit&quot].items():
            assert set(debug_returned[&quotfit&quot][block_name].keys()) == set(dictionary.keys())

        for block_name, dictionary in expected_return[&quotproduce&quot].items():
            assert set(debug_returned[&quotproduce&quot][block_name].keys()) == set(dictionary.keys())

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_predict_no_debug(self):
        outputs = {
            &quotdefault&quot: [
                {
                    &quotname&quot: &quota_name&quot,
                    &quotvariable&quot: &quota_primitive&#47&#471.a_variable&quot,
                    &quottype&quot: &quota_type&quot,
                },
                {
                    &quotname&quot: &quotb_name&quot,
                    &quotvariable&quot: &quota_primitive&#47&#471.b_variable&quot,
                    &quottype&quot: &quotb_type&quot,
                },
            ]
        }
        mlpipeline = MLPipeline([&quota_primitive&quot], outputs=outputs)
        mlpipeline.blocks[&quota_primitive&#47&#471&quot].produce_args = [
            {
                &quotname&quot: &quotinput&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]

        mlpipeline.blocks[&quota_primitive&#47&#471&quot].produce_output = [
            {
                &quotname&quot: &quota_name&quot,
                &quottype&quot: &quota_type&quot
            },
            {
                &quotname&quot: &quotb_name&quot,
                &quottype&quot: &quotb_type&quot
            }
        ]

        returned = mlpipeline.predict(debug=False)
        assert len(returned) == len(outputs[&quotdefault&quot])
        for returned_output, expected_output in zip(returned, outputs[&quotdefault&quot]):
            assert returned_output == expected_output[&quotvariable&quot]

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_predict_debug(self):
        outputs = {
            &quotdefault&quot: [
                {
                    &quotname&quot: &quota_name&quot,
                    &quotvariable&quot: &quota_primitive&#47&#471.a_variable&quot,
                    &quottype&quot: &quota_type&quot,
                }
            ]
        }
        mlpipeline = MLPipeline([&quota_primitive&quot], outputs=outputs)
        mlpipeline.blocks[&quota_primitive&#47&#471&quot].produce_args = [
            {
                &quotname&quot: &quotinput&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]

        mlpipeline.blocks[&quota_primitive&#47&#471&quot].produce_output = [
            {
                &quotname&quot: &quota_name&quot,
                &quottype&quot: &quota_type&quot
            }
        ]

        expected_return = dict()
        expected_return = {
            &quota_primitive&#47&#471&quot: {
                &quottime&quot: 0,
                &quotinput&quot: {
                    &quotwhatever&quot
                },
                &quotoutput&quot: {
                    &quotwhatever&quot
                },
                &quotmemory&quot: 0
            }
        }

        returned, debug_returned = mlpipeline.predict(debug=True)
        debug_returned = debug_returned[&quotproduce&quot]

        assert len([returned]) == len(outputs[&quotdefault&quot])
        assert isinstance(debug_returned, dict)
        assert set(debug_returned.keys()) == set(expected_return.keys())

        for block_name, dictionary in expected_return.items():
            assert set(debug_returned[block_name].keys()) == set(dictionary.keys())

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_diagram_simple(self):
        f = open(&quottests/data/diagrams/diagram_simple.txt&quot, &quotr&quot)
        expected = f.read()[:-1]
        f.close()

        output = [
            {
                &quotname&quot: &quotoutput_variable&quot,
                &quottype&quot: &quotanother_whatever&quot,
                &quotvariable&quot: &quota_primitive&#47&#471.output_variable&quot
            }
        ]

        pipeline = MLPipeline([&quota_primitive&quot], outputs={&quotdefault&quot: output})
        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_args = [
            {
                &quotname&quot: &quotinput_variable&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]
        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_output = output

        assert str(pipeline.get_diagram()) == expected

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_diagram_fit(self):
        f = open(&quottests/data/diagrams/diagram_fit.txt&quot, &quotr&quot)
        expected = f.read()[:-1]
        f.close()

        output = [
            {
                &quotname&quot: &quotoutput_variable&quot,
                &quottype&quot: &quotanother_whatever&quot,
                &quotvariable&quot: &quota_primitive&#47&#471.output_variable&quot
            }
        ]

        pipeline = MLPipeline([&quota_primitive&quot], outputs={&quotdefault&quot: output})
        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_args = [
            {
                &quotname&quot: &quotinput_variable&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]
        pipeline.blocks[&quota_primitive&#47&#471&quot].fit_args = [
            {
                &quotname&quot: &quotinput_variable&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]
        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_output = output

        assert str(pipeline.get_diagram()) == expected

    @patch(&quotmlblocks.mlpipeline.MLBlock&quot, new=get_mlblock_mock)
    def test_get_diagram_multiple_blocks(self):
        <a id="change">f = open(&quottests/data/diagrams/diagram_multiple_blocks.txt&quot, &quotr&quot)</a>
        expected = f.read()[:-1]
        <a id="change">f</a><a id="change">.close()</a>

        first_output = [
            {
                &quotname&quot: &quotoutput_variable_a&quot,
                &quottype&quot: &quotanother_whatever&quot,
                &quotvariable&quot: &quota_primitive&#47&#471.output_variable_a&quot
            }
        ]
        second_output = [
            {
                &quotname&quot: &quotoutput_variable_b&quot,
                &quottype&quot: &quotanother_whatever&quot,
                &quotvariable&quot: &quotb_primitive&#47&#471.output_variable_b&quot
            }
        ]

        pipeline = MLPipeline([&quota_primitive&quot, &quotb_primitive&quot], outputs={&quotdefault&quot: second_output})
        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_args = [
            {
                &quotname&quot: &quotinput_variable&quot,
                &quottype&quot: &quotwhatever&quot
            }
        ]
        pipeline.blocks[&quota_primitive&#47&#471&quot].produce_output = first_output
        pipeline.blocks[&quotb_primitive&#47&#471&quot].produce_args = first_output
        pipeline.blocks[&quotb_primitive&#47&#471&quot].produce_output = second_output

        assert str(pipeline.get_diagram()) == expected

    def test_fit(self):
        pass

    def test_predict(self):
        pass

    def test_to_dict(self):
        pass

    def test_save(self):
        pass

    def test_from_dict(self):
        pass

    def test_load(self):
        pass
</code></pre>