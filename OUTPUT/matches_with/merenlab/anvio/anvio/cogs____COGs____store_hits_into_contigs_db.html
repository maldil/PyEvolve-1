<link rel="stylesheet" href="../../..//default.css">
<script src="../../..//highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><pre><code class='java'>
<a href="https://github.com/merenlab/anvio/blob/master/anvio/cogs.py#L223">GitHubLink</a>


<a href="https://github.com/maldil/anvio/blob/master/anvio/cogs.py#L223">GitMyHubLink</a>

&#47&#47 -*- coding: utf-8
&#47&#47 pylint: disable=line-too-long

    Making sense of COGs.


import os
import sys
import gzip
import glob
import shutil

import anvio
import anvio.utils as utils
import anvio.dbops as dbops
import anvio.dictio as dictio
import anvio.terminal as terminal
import anvio.filesnpaths as filesnpaths

from anvio.errors import ConfigError
from anvio.drivers.blast import BLAST
from anvio.drivers.diamond import Diamond
from anvio.tables.genefunctions import TableForGeneFunctions

&#47&#47 just to make sure things don&quott break too far when they do:
COG_DATA_VERSION=&quot2&quot


__author__ = "Developers of anvi&quoto (see AUTHORS.txt)"
__copyright__ = "Copyleft 2015-2018, the Meren Lab (http://merenlab.org/)"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__maintainer__ = "A. Murat Eren"
__email__ = "a.murat.eren@gmail.com"


run = terminal.Run()
progress = terminal.Progress()
pp = terminal.pretty_print
P = terminal.pluralize

J = lambda x, y: os.path.join(x, y)


class Args():
    pass


class COGs:
    A class to run COGs
    def __init__(self, args=Args(), run=run, progress=progress):
        self.args = args
        self.run = run
        self.progress = progress

        A = lambda x: args.__dict__[x] if x in args.__dict__ else None
        self.num_threads = A(&quotnum_threads&quot)
        self.contigs_db_path = A(&quotcontigs_db&quot)
        self.search_with = A(&quotsearch_with&quot) or &quotdiamond&quot
        self.temp_dir_path = A(&quottemporary_dir_path&quot)
        self.sensitive = A(&quotsensitive&quot)

        self.log_file_path = None

        self.default_search_method = &quotdiamond&quot
        self.search_methods_factory = {&quotdiamond&quot: self.search_with_diamond,
                                       &quotblastp&quot: self.search_with_ncbi_blast}
        self.available_search_methods = [p for p in self.search_methods_factory.keys() if utils.is_program_exists(p, dont_raise=True)]

        if not len(self.available_search_methods):
            raise ConfigError("None of the search methods this class could use, which include &quot%s&quot, seem to be "
                              "available on your system :/" % (&quot, &quot.join(list(self.search_methods_factory.keys()))))

        if self.default_search_method not in self.available_search_methods:
            self.default_search_method = self.available_search_methods[0]

        if len(args.__dict__):
            self.initialize(args)


    def initialize(self, args):
        self.hits = None &#47&#47 the search function will take care of this one.

        &#47&#47 get an instance of the setup class
        self.COG_setup = COGsSetup(args)

        self.COG_data_dir = self.COG_setup.COG_data_dir
        self.COG_base_dir = self.COG_setup.COG_base_dir
        self.COG_version = self.COG_setup.COG_version
        self.available_db_search_program_targets = self.COG_setup.get_formatted_db_paths()
        self.essential_files = self.COG_setup.get_essential_file_paths()

        &#47&#47 this is an additional check after the 2020 COG release.
        if os.path.exists(os.path.join(self.COG_base_dir, &quotCOG.txt&quot)):
            &#47&#47 This means that this installation still has the old COG data. Let&quots try to solve it:
            self.move_old_COG_data_to_its_new_location()

        &#47&#47 Check whether there is data for the version requested
        data_available_for_cog_versions = [os.path.basename(d) for d in glob.glob(os.path.join(self.COG_base_dir, &quotCOG*&quot))]
        if not len(data_available_for_cog_versions):
            raise ConfigError("You don&quott seem to have any COG data setup in your COG data directory. Please first run "
                              "`anvi-setup-ncbi-cogs` to take care of that.")
        elif self.COG_version not in data_available_for_cog_versions:
            if self.COG_version == "COG20" and len(data_available_for_cog_versions) == 1 and data_available_for_cog_versions[0] == "COG14":
                raise ConfigError("OK. There is a problem, but it is easy to solve: On this system you have the data for the 2014 "
                                  "release of the NCBI&quots COGs. But the NCBI recently made a new release, and `anvi-run-ncbi-cogs` "
                                  "sets the COG data version to that release. If you want to run the older data, you can rerun your "
                                  "command by adding the parameter `--cog-version COG14`. If you want to take this opportunity to "
                                  "setup the new COG data (which you totally should), please go ahead and run `anvi-setup-ncbi-cogs`.")
            else:
                raise ConfigError(f"You requested to run the NCBI COGs using the version &quot{self.COG_version}&quot, but you don&quott have "
                                  f"the data to be able to run that version of COGs setup on this system yet. Here is the "
                                  f"{P(&quotversion&quot, len(data_available_for_cog_versions), pfs=&quotonly&quot)} available "
                                  f"for COGs on this system: {&quot, &quot.join(data_available_for_cog_versions)}. You can "
                                  f"either specify which version you wish to use through the parameter `--cog-version`, or you can "
                                  f"run the following command to setup the data files for the version you wish to use: "
                                  f"`anvi-setup-ncbi-cogs --cog-version {self.COG_version}`, and re-run the same command that brought "
                                  f"you here.")


    def move_old_COG_data_to_its_new_location(self):
        try:
            filesnpaths.is_output_dir_writable(self.COG_base_dir)
        except:
            raise ConfigError(f"Please read this carefully: The NCBI has made a new release of COGs. To make room for that "
                              f"while maintaining the old COG data from 2014 version, anvi&quoto needs to move some files around. "
                              f"While anvi&quoto can do it automatically, your user does not seem to have permission to do that. "
                              f"One alternative is to ask your system administrator to run this program on your behalf. It will "
                              f"solve everything. OR you can ask them to do exactly these steps: (1) go to the directory "
                              f"&quot{self.COG_base_dir}&quot, (2) create a new directory called `COG14`, and (3) move everything in "
                              f"&quot{self.COG_base_dir}&quot (WHICH INCLUDES the files: CATEGORIES.txt, COG.txt, DB_BLAST/ "
                              f"DB_DIAMOND/, MISSING_COG_IDs.cPickle, PID-TO-CID.cPickle, and RAW_DATA_FROM_NCBI/ as well as the "
                              f"hidden file .VERSION) into the new `COG14` directory. Then you will be golden.")

        &#47&#47 we have the write permission, so let&quots do this.
        tmp_dir = filesnpaths.get_temp_directory_path(just_the_path=True)
        self.run.warning(f"This is a bit important: The NCBI has made a new release of COGs. To make room for that "
                         f"while maintaining the old COG data from 2014 version, anvi&quoto needs to move some files around. "
                         f"It seems you have the necessary permissions to write into anvi&quoto misc data directory, so anvi&quoto "
                         f"will now attempt to do it automatically by first moving things to a temporary directory "
                         f"(&quot{tmp_dir}&quot) and then moving them back into their new target location. If you have not been "
                         f"having an exceptionally bad day, this should go smoothly. But if you see an error below, anvi&quoto is "
                         f"very sorry for breaking itself on your system :( In which case please find us on our Slack channel "
                         f"and we will try to help you to sort things out.")
        self.progress.new("Moving files around")
        shutil.move(self.COG_base_dir, tmp_dir)
        os.makedirs(self.COG_base_dir)
        shutil.move(tmp_dir, os.path.join(self.COG_base_dir, &quotCOG14&quot))

        self.run.info_single("Congratulations! Anvi&quoto managed to migrate your old data into its new location without breaking "
                             "things. We are all very proud here but let&quots never do this again.", mc=&quotgreen&quot, nl_after=1)


    def process(self, aa_sequences_file_path=None):
        if self.search_with not in self.available_search_methods:
            raise ConfigError("Let us start by making it clear that we probably like &quot%s&quot as much as you do, but it doesn&quott "
                              "seem to be available on your system OR recognized by the COGs class since anvi&quoto couldn&quott "
                              "find it among the available search methods. You probably need to try something else :/" \
                                                                                                    % self.search_with)

        if self.search_with not in self.available_db_search_program_targets:
            raise ConfigError("Anvi&quoto understands that you want to use &quot%s&quot to search for COGs, however, there is no "
                              "database formatted under the COGs data directory for that program :/ You may need to "
                              "re-run the COGs setup (anvi-setup-ncbi-cogs), UNLESS, you set up your COG data directory "
                              "somewhere else than what anvi&quoto attempts to use at the moment (&quot%s&quot). If that is the case, "
                              "this may be the best time to point the right directory using the --cog-data-dir parameter, "
                              "or the environmental variable &quotANVIO_COG_DATA_DIR&quot." % (self.search_with, self.COG_data_dir))

        if not aa_sequences_file_path and not self.contigs_db_path:
            raise ConfigError("You either need to provide an anvi&quoto contigs database path, or a FASTA file for AA "
                              "sequences")

        if aa_sequences_file_path and self.contigs_db_path:
            raise ConfigError("You can&quott provide both an AA sequences file and a contigs database. Choose one!")

        if self.contigs_db_path:
            utils.is_contigs_db(self.contigs_db_path)

        if not self.temp_dir_path:
            self.temp_dir_path = filesnpaths.get_temp_directory_path()
            self.remove_temp_dir_path = True
        else:
            filesnpaths.is_file_exists(self.temp_dir_path)
            filesnpaths.is_output_dir_writable(self.temp_dir_path)

            self.run.warning("Because you set the temporary directory path by hand, anvi&quoto will not remove its content "
                             "when it is done. But she certainly hopes that you will clean those files later.")

            self.remove_temp_dir_path = False

        self.run.info(&quotCOG data directory&quot, self.COG_data_dir)
        self.run.info(&quotSearching with&quot, self.search_with)
        self.run.info(&quotDirectory to store temporary files&quot, self.temp_dir_path)
        self.run.info(&quotDirectory will be removed after the run&quot, self.remove_temp_dir_path)


        if not aa_sequences_file_path:
            aa_sequences_file_path = J(self.temp_dir_path, &quotaa_sequences.fa&quot)
            dbops.ContigsSuperclass(self.args, r=terminal.Run(verbose=False)).get_sequences_for_gene_callers_ids(output_file_path=aa_sequences_file_path,
                                                                                  report_aa_sequences=True,
                                                                                  simple_headers=True)

        &#47&#47 do the search
        search_results_tabular = self.search_methods_factory[self.search_with](aa_sequences_file_path)

        &#47&#47 convert the output to a hits dict
        if self.COG_version == &quotCOG14&quot:
            self.hits = utils.get_BLAST_tabular_output_as_dict(search_results_tabular, target_id_parser_func=lambda x: x.split(&quot|&quot)[1])
        elif self.COG_version == &quotCOG20&quot:
            self.hits = utils.get_BLAST_tabular_output_as_dict(search_results_tabular)
        else:
            raise ConfigError("You need to edit all the if/else statements with COG version checks to ensure proper "
                              "parsing of a new generation of COG files.")

        &#47&#47 store hits into the contigs database
        self.store_hits_into_contigs_db()

        if self.remove_temp_dir_path:
            shutil.rmtree(self.temp_dir_path)


    def store_hits_into_contigs_db(self):
        if not self.hits:
            self.run.warning("COGs class has no hits to process. Returning empty handed, but still adding COGs as "
                             "functional sources.")
            gene_function_calls_table = TableForGeneFunctions(self.contigs_db_path, self.run, self.progress)

            if self.COG_version == &quotCOG14&quot:
                gene_function_calls_table.add_empty_sources_to_functional_sources({&quotCOG14_FUNCTION&quot, &quotCOG14_CATEGORY&quot})
            elif self.COG_version == &quotCOG20&quot:
                gene_function_calls_table.add_empty_sources_to_functional_sources({&quotCOG20_FUNCTION&quot, &quotCOG20_CATEGORY&quot, &quotCOG20_PATHWAY&quot})
            else:
                raise ConfigError("You need to edit all the if/else statements with COG version checks to ensure proper "
                                  "parsing of a new generation of COG files.")
            return

        cogs_data = COGsData(self.args)
        cogs_data.init_p_id_to_cog_id_dict()

        functions_dict = {}
        self.__entry_id = 0


        def add_entry(gene_callers_id, source, accession, function, e_value):
            functions_dict[self.__entry_id] = {&quotgene_callers_id&quot: int(gene_callers_id),
                                               &quotsource&quot: source,
                                               &quotaccession&quot: accession,
                                               &quotfunction&quot: function,
                                               &quote_value&quot: float(e_value)}
            self.__entry_id += 1

        &#47&#47 let&quots keep track of hits that match to missing COGs
        hits_for_missing_cogs = 0
        hits_for_missing_ncbi_protein_ids = 0

        missing_cogs_found = set([])
        missing_ncbi_protein_ids_found = set([])

        for gene_callers_id in self.hits:
            ncbi_protein_id = self.hits[gene_callers_id][&quothit&quot]

            in_proteins_FASTA_not_in_cogs_CSV = []
            if ncbi_protein_id not in cogs_data.p_id_to_cog_id:
                in_proteins_FASTA_not_in_cogs_CSV.append((ncbi_protein_id, gene_callers_id),)
                missing_ncbi_protein_ids_found.add(ncbi_protein_id)
                hits_for_missing_ncbi_protein_ids += 1
                continue

            COG_ids = cogs_data.p_id_to_cog_id[ncbi_protein_id]

            annotations = []
            categories = []
            pathways = []
            category_descriptions = []
            for COG_id in COG_ids:
                &#47&#47 is missing?
                if COG_id in cogs_data.missing_cogs:
                    missing_cogs_found.add(COG_id)
                    hits_for_missing_cogs += 1
                    continue

                &#47&#47 resolve categories
                for category in cogs_data.cogs[COG_id][&quotcategories&quot]:
                    categories.append(category)
                    category_descriptions.append(cogs_data.categories[category])

                &#47&#47 append annotation
                annotations.append(cogs_data.cogs[COG_id][&quotannotation&quot])

                if self.COG_version == &quotCOG14&quot:
                    pass
                elif self.COG_version == &quotCOG20&quot:
                    if cogs_data.cogs[COG_id][&quotpathway&quot]:
                        pathways.append(cogs_data.cogs[COG_id][&quotpathway&quot])
                else:
                    raise ConfigError("You need to edit all the if/else statements with COG version checks to ensure proper "
                                      "parsing of a new generation of COG files.")

            &#47&#47 all these shitty heuristics... If there are multiple COG ids or categories, separate them from each other by &quot!!!&quot so parsing
            &#47&#47 them later is possible. Am I embarrassed? Yes. Is there a better way of doing this efficiently? Absolutely. What time is it?
            &#47&#47 9pm. Where am I? In the lab. Is it OK for me to let this slip away if it means for me to go home sooner? Yes, probably. Am I
            &#47&#47 gonna remember this crap in the code for the next two months at random times in the shower and feel bad about myself? Fuck yes.
            if self.COG_version == &quotCOG14&quot:
                add_entry(gene_callers_id, f&quot{self.COG_version}_FUNCTION&quot, &quot!!!&quot.join(COG_ids), &quot!!!&quot.join(annotations), self.hits[gene_callers_id][&quotevalue&quot])
                add_entry(gene_callers_id, f&quot{self.COG_version}_CATEGORY&quot, &quot!!!&quot.join(categories), &quot!!!&quot.join(category_descriptions), 0.0)
            elif self.COG_version == &quotCOG20&quot:
                add_entry(gene_callers_id, f&quot{self.COG_version}_FUNCTION&quot, &quot!!!&quot.join(COG_ids), &quot!!!&quot.join(annotations), self.hits[gene_callers_id][&quotevalue&quot])
                add_entry(gene_callers_id, f&quot{self.COG_version}_CATEGORY&quot, &quot!!!&quot.join(categories), &quot!!!&quot.join(category_descriptions), 0.0)
                if len(pathways):
                    add_entry(gene_callers_id, f&quot{self.COG_version}_PATHWAY&quot, &quot!!!&quot.join(COG_ids), &quot!!!&quot.join(pathways), self.hits[gene_callers_id][&quotevalue&quot])
            else:
                raise ConfigError("You need to edit all the if/else statements with COG version checks to ensure proper "
                                  "parsing of a new generation of COG files.")

        &#47&#47 store hits in contigs db.
        gene_function_calls_table = TableForGeneFunctions(self.contigs_db_path, self.run, self.progress)
        gene_function_calls_table.create(functions_dict)

        if len(missing_cogs_found):
            self.run.warning(&quotAlthough your COGs are successfully added to the database, there were some COG IDs your genes hit &quot
                             &quotwere among the ones that were not described in the raw data. Here is the list of %d COG IDs that &quot
                             &quotwere hit %d times: %s.&quot % (len(missing_cogs_found), hits_for_missing_cogs, &quot, &quot.join(missing_cogs_found)))

        if len(missing_ncbi_protein_ids_found):
            self.run.warning("Well. Your COGs were successfully added to the database, but there were some garbage anvi&quoto brushed "
                             "off under the rug. There were %d genes in your database that hit %d protein IDs in NCBIs COGs database, "
                             "but since NCBI did not release what COGs they correspond to in the database they made available (that "
                             "helps us to resolve protein IDs to COG ids), we could not annotate those genes with functions. Anvi&quoto "
                             "apologizes on behalf of all computer scientists for half-done stuff we often force biologists to deal "
                             "with. If you want to do some Googling, these were the offending protein IDs: &quot%s&quot." % \
                                        (hits_for_missing_ncbi_protein_ids, len(missing_ncbi_protein_ids_found), &quot, &quot.join([str(s) for s in missing_ncbi_protein_ids_found])))

        if len(in_proteins_FASTA_not_in_cogs_CSV):
            &#47&#47 so some of the hits represented in the FASTA file from the NCBI were not put in the
            &#47&#47 CSV file from NCBI to associate them with COGs
            report_output_file_path = filesnpaths.get_temp_file_path()
            <a id="change">report_output = open(report_output_file_path, &quotw&quot)</a>
            report_output.write(&quotanvio_gene_callers_id\tNCBI_protein_id\n&quot)

            for protein_id, gene_callers_id in in_proteins_FASTA_not_in_cogs_CSV:
                report_output.write(&quot%s\t%s\n&quot % (gene_callers_id, protein_id))

            <a id="change">report_output</a><a id="change">.close()</a>

            self.run.warning("This is important. %s hits for your genes that appeared in the proteins FASTA file from the NCBI had protein "
                             "IDs that were not described in the CSV file from the NCBI that associates each protein ID with a COG function. "
                             "That&quots OK if you don&quott care. But if you would like to take a look, anvi&quoto stored a report "
                             "file for you at %s" \
                        % (len(in_proteins_FASTA_not_in_cogs_CSV), report_output_file_path))


    def search_with_diamond(self, aa_sequences_file_path):
        diamond = Diamond(aa_sequences_file_path, run=self.run, progress=self.progress, num_threads=self.num_threads)

        diamond.target_fasta = self.available_db_search_program_targets[&quotdiamond&quot]
        self.run.log_file_path = self.log_file_path or J(self.temp_dir_path, &quotlog.txt&quot)
        diamond.search_output_path = J(self.temp_dir_path, &quotdiamond-search-results&quot)
        diamond.tabular_output_path = J(self.temp_dir_path, &quotdiamond-search-results.txt&quot)

        diamond.sensitive = self.sensitive
        diamond.max_target_seqs = 1

        diamond.blastp()
        diamond.view()

        return diamond.tabular_output_path


    def search_with_ncbi_blast(self, aa_sequences_file_path):
        blast = BLAST(aa_sequences_file_path, run=self.run, progress=self.progress, num_threads=self.num_threads)

        blast.target_fasta = self.available_db_search_program_targets[&quotblastp&quot]
        self.run.log_file_path = self.log_file_path or J(self.temp_dir_path, &quotlog.txt&quot)
        blast.search_output_path = J(self.temp_dir_path, &quotblast-search-results.txt&quot)
        blast.max_target_seqs = 1

        blast.blast()

        return blast.search_output_path


class COGsData:
    A class to make sense of COG ids and categories
    def __init__(self, args=Args(), cog_data_dir = None, run=run, progress=progress, panic_on_failure_to_init=False):
        self.run = run
        self.progress = progress

        if cog_data_dir:
            args.cog_data_dir = cog_data_dir

        self.setup = COGsSetup(args)
        self.essential_files = self.setup.get_essential_file_paths()
        self.COG_version = self.setup.COG_version

        self.cogs = None
        self.p_id_to_cog_id = None
        self.missing_cogs = None
        self.categories = None
        self.initialized = False

        if self.essential_files:
            self.init()
        elif panic_on_failure_to_init:
            raise ConfigError("It seems you don&quott have your COG data set up on this system. Whatever you were "
                              "trying to do is not going to continue being done :( Did you setup your COGs? If "
                              "not, you can take a look at the program `anvi-setup-ncbi-cogs`. Maybe you did "
                              "setup into another directory than the default destination? If that is the case "
                              "maybe you can use the `--cog-data-dir` parameter if it is applicable? No? None "
                              "of these work? Well. Anvi&quoto hates it as much as you do when things come to this.")


    def init(self):
        self.progress.new(&quotInitializing COGs Data&quot)
        self.progress.update(&quotReading COG functions ...&quot)

        if self.COG_version == &quotCOG14&quot:
            self.cogs = utils.get_TAB_delimited_file_as_dictionary(self.essential_files[&quotCOG.txt&quot], no_header=True, column_names=[&quotCOG&quot, &quotcategories&quot, &quotannotation&quot])
        elif self.COG_version == &quotCOG20&quot:
            self.cogs = utils.get_TAB_delimited_file_as_dictionary(self.essential_files[&quotCOG.txt&quot], no_header=True, column_names=[&quotCOG&quot, &quotcategories&quot, &quotannotation&quot, &quotpathway&quot])
        else:
            raise ConfigError("You need to edit all the if/else statements with COG version checks to ensure proper "
                              "parsing of a new generation of COG files.")


        self.progress.update(&quotReading COG categories ...&quot)
        self.categories = utils.get_TAB_delimited_file_as_dictionary(self.essential_files[&quotCATEGORIES.txt&quot], no_header=True, column_names=[&quotcategory&quot, &quotdescription&quot])

        self.progress.update(&quotReading missing COG IDs ...&quot)
        self.missing_cogs = dictio.read_serialized_object(self.essential_files[&quotMISSING_COG_IDs.cPickle&quot])

        self.progress.end()

        for cog in self.cogs:
            self.cogs[cog][&quotcategories&quot] = [c.strip() for c in self.cogs[cog][&quotcategories&quot].split(&quot,&quot)]

        for cat in self.categories:
            self.categories[cat] = self.categories[cat][&quotdescription&quot]

        self.initialized = True


    def init_p_id_to_cog_id_dict(self):
        self.progress.new(&quotInitializing COGs Data&quot)
        self.progress.update(&quotReading NCBI Protein ID to COG id converter ...&quot)

        self.p_id_to_cog_id = dictio.read_serialized_object(self.essential_files[&quotPID-TO-CID.cPickle&quot])

        self.progress.end()


class COGsSetup:
    A class to download and setup the COG data from NCBI.
    def __init__(self, args=Args(), cog_data_dir = None, run=run, progress=progress):
        self.run = run
        self.progress = progress

        &#47&#47 description of COG primary files per version
        self.cog_files = {&quotCOG14&quot:
                             {&quotcog2003-2014.csv&quot: {
                                  &quoturl&quot: &quotftp://ftp.ncbi.nih.gov/pub/COG/COG2014/data/cog2003-2014.csv&quot,
                                  &quotfunc&quot: self.format_p_id_to_cog_id_cPickle,
                                  &quottype&quot: &quotessential&quot,
                                  &quotformatted_file_name&quot: &quotPID-TO-CID.cPickle&quot},
                              &quotcognames2003-2014.tab&quot: {
                                  &quoturl&quot: &quotftp://ftp.ncbi.nih.gov/pub/COG/COG2014/data/cognames2003-2014.tab&quot,
                                  &quotfunc&quot: self.format_cog_names,
                                  &quottype&quot: &quotessential&quot,
                                  &quotformatted_file_name&quot: &quotCOG.txt&quot},
                              &quotfun2003-2014.tab&quot: {
                                  &quoturl&quot: &quotftp://ftp.ncbi.nih.gov/pub/COG/COG2014/data/fun2003-2014.tab&quot,
                                  &quotfunc&quot: self.format_categories,
                                  &quottype&quot: &quotessential&quot,
                                  &quotformatted_file_name&quot: &quotCATEGORIES.txt&quot},
                              &quotprot2003-2014.fa.gz&quot: {
                                  &quoturl&quot: &quotftp://ftp.ncbi.nih.gov/pub/COG/COG2014/data/prot2003-2014.fa.gz&quot,
                                  &quotfunc&quot: self.format_protein_db,
                                  &quottype&quot: &quotdatabase&quot,
                                  &quotformatted_file_name&quot: &quotIGNORE_THIS_AND_SEE_THE_FUNCTION&quot}
                             },
                        &quotCOG20&quot:
                             {&quotcog-20.cog.csv&quot: {
                                  &quoturl&quot: &quotftp://ftp.ncbi.nih.gov/pub/COG/COG2020/data/cog-20.cog.csv&quot,
                                  &quotfunc&quot: self.format_p_id_to_cog_id_cPickle,
                                  &quottype&quot: &quotessential&quot,
                                  &quotformatted_file_name&quot: &quotPID-TO-CID.cPickle&quot},
                              &quotcog-20.def.tab&quot: {
                                  &quoturl&quot: &quotftp://ftp.ncbi.nih.gov/pub/COG/COG2020/data/cog-20.def.tab&quot,
                                  &quotfunc&quot: self.format_cog_names,
                                  &quottype&quot: &quotessential&quot,
                                  &quotformatted_file_name&quot: &quotCOG.txt&quot},
                              &quotfun-20.tab&quot: {
                                  &quoturl&quot: &quotftp://ftp.ncbi.nih.gov/pub/COG/COG2020/data/fun-20.tab&quot,
                                  &quotfunc&quot: self.format_categories,
                                  &quottype&quot: &quotessential&quot,
                                  &quotformatted_file_name&quot: &quotCATEGORIES.txt&quot},
                              &quotcog-20.fa.gz&quot: {
                                  &quoturl&quot: &quotftp://ftp.ncbi.nih.gov/pub/COG/COG2020/data/cog-20.fa.gz&quot,
                                  &quotfunc&quot: self.format_protein_db,
                                  &quottype&quot: &quotdatabase&quot,
                                  &quotformatted_file_name&quot: &quotIGNORE_THIS_AND_SEE_THE_FUNCTION&quot}
                             },
                         }

        A = lambda x: args.__dict__[x] if x in args.__dict__ else None
        self.num_threads = A(&quotnum_threads&quot) or 1
        self.just_do_it = A(&quotjust_do_it&quot)
        self.reset = A(&quotreset&quot)
        self.COG_data_source = &quotunknown&quot
        self.COG_version = A(&quotcog_version&quot) or &quotCOG20&quot

        if self.COG_version not in self.cog_files:
            raise ConfigError(f"The COG versions known to anvi&quoto do not include &quot{self.COG_version}&quot :/ This is "
                              f"what we know of: {&quot, &quot.join(self.cog_files.keys())}. This is one of those things "
                              f"that should have never happened. We salute you.")

        if cog_data_dir:
            self.COG_base_dir = cog_data_dir
            self.COG_data_source = &quotThe function call.&quot
        elif A(&quotcog_data_dir&quot):
            self.COG_base_dir = A(&quotcog_data_dir&quot)
            self.COG_data_source = &quotThe command line parameter.&quot
        elif &quotANVIO_COG_DATA_DIR&quot in os.environ:
            self.COG_base_dir = os.environ[&quotANVIO_COG_DATA_DIR&quot]
            self.COG_data_source = &quotThe environmental variable.&quot
        else:
            self.COG_base_dir = J(os.path.dirname(anvio.__file__), &quotdata/misc/COG&quot)
            self.COG_data_source = "The anvi&quoto default."

        self.COG_base_dir = os.path.abspath(os.path.expanduser(self.COG_base_dir))
        self.COG_data_dir = os.path.join(self.COG_base_dir, self.COG_version)

        self.run.info(&quotCOG version&quot, self.COG_version, mc=&quotgreen&quot)
        self.run.info(&quotCOG data source&quot, self.COG_data_source)
        self.run.info(&quotCOG base directory&quot, self.COG_base_dir)

        self.COG_data_dir_version = J(self.COG_data_dir, &quot.VERSION&quot)
        self.raw_NCBI_files_dir = J(self.COG_data_dir, &quotRAW_DATA_FROM_NCBI&quot)

        self.files = self.cog_files[self.COG_version]

        self.cogs_found_in_proteins_fasta = set([])
        self.cogs_found_in_cog_names_file = set([])


    def get_formatted_db_paths(self):
        formatted_db_paths = {}

        diamond_db_path = J(self.COG_data_dir, &quotDB_DIAMOND&quot)
        if os.path.exists(diamond_db_path):
            formatted_db_paths[&quotdiamond&quot] = J(diamond_db_path, &quotCOG&quot)

        blast_db_path = J(self.COG_data_dir, &quotDB_BLAST&quot)
        if os.path.exists(blast_db_path):
            formatted_db_paths[&quotblastp&quot] = J(blast_db_path, &quotCOG/COG.fa&quot)

        return formatted_db_paths


    def get_essential_file_paths(self):
        if not os.path.exists(self.COG_data_dir):
            &#47&#47 the COG_data_dir is not there
            return None

        essential_files = {}
        for v in list(self.files.values()):
            if v[&quottype&quot] == &quotessential&quot:
                essential_files[v[&quotformatted_file_name&quot]] = J(self.COG_data_dir, v[&quotformatted_file_name&quot])

        &#47&#47 add the missing COG IDs file into the list:
        essential_files[&quotMISSING_COG_IDs.cPickle&quot] = J(self.COG_data_dir, &quotMISSING_COG_IDs.cPickle&quot)

        for file_name in essential_files:
            if not os.path.exists(essential_files[file_name]):
                raise ConfigError("At least one essential formatted file that is necesary for COG operations is not where it should "
                                   "be (&quot%s&quot). You should run COG setup, with the flag `--reset` if necessary, to make sure things "
                                   "are in order." % essential_files[file_name])

        return essential_files


    def create(self):
        if not os.path.exists(self.COG_data_dir):
            try:
                os.makedirs(self.COG_data_dir)
                open(self.COG_data_dir_version, &quotw&quot).write(COG_DATA_VERSION)
            except Exception as e:
                raise ConfigError(f"So the COG data directory is not there, and anvi&quoto wants to create one. But it didn&quott "
                                  f"go that well. It could be due to permissions (which may require you to run this with sudo "
                                  f"or may need to ask your sys admin to do it for you since this is a one time operation), or "
                                  f"it could be due to something totally irrelevant. Here is the error message: {e}.")

        filesnpaths.is_output_dir_writable(self.COG_data_dir)

        if self.reset:
            run.warning(&quotThis program will remove everything in the COG data directory, then download and reformat &quot
                        &quoteverything from scratch.&quot)

            &#47&#47 OK. reset the crap out of it.
            shutil.rmtree(self.COG_data_dir)
            os.mkdir(self.COG_data_dir)
            open(self.COG_data_dir_version, &quotw&quot).write(COG_DATA_VERSION)
        else:
            run.warning("This program will first check whether you have all the raw files, and then will attempt to "
                        "regenerate everything that is necessary from them.")

        if not os.path.exists(self.COG_data_dir_version) or open(self.COG_data_dir_version).read().strip() != COG_DATA_VERSION:
            raise ConfigError("The version of your COG data directory is different than what anvi&quoto hoping to see. "
                               "It seems you need to (re)run anvi&quoto script to download and format COG data from NCBI.")

        &#47&#47 get raw files
        self.get_raw_data()

        &#47&#47 format raw files
        self.setup_raw_data()

        &#47&#47 identify missing COGs
        self.generate_missing_cog_ids_file()


    def generate_missing_cog_ids_file(self):
        missing_cog_ids = self.cogs_found_in_proteins_fasta.difference(self.cogs_found_in_cog_names_file)

        if len(missing_cog_ids):
            self.run.warning("%d of %d COG IDs that appear in the list of orthology domains file (which links protein IDs "
                             "to COG names), are missing from the COG names file (which links COG IDs to function names and "
                             "categories). Because clearly even the files that are distributed together should not be expected to "
                             "be fully compatible. Anvi&quoto thanks everyone for their contributions." % \
                                                        (len(missing_cog_ids), len(self.cogs_found_in_proteins_fasta)))

        dictio.write_serialized_object(missing_cog_ids, J(self.COG_data_dir, &quotMISSING_COG_IDs.cPickle&quot))


    def format_p_id_to_cog_id_cPickle(self, input_file_path, output_file_path):
        num_lines_in_file = filesnpaths.get_num_lines_in_file(input_file_path)

        def raise_error(line_num, line_content, fields, e):
            raise ConfigError(f"Bad news :( While parsing a COG input file, anvi&quoto encountered an error (which said: [{e}]) "
                              f"while processing the line {line_counter} in your file. Where the fields in that file looked "
                              f"looked like this: {fields}. Sadly, this has been a long-standing and very annoying issue that "
                              f"anvi&quoto developers were unable to reproduce. But we recently learned that the issue is likely due "
                              f"to your internet speed (https://github.com/merenlab/anvio/issues/1738). Slower connections lead "
                              f"to broken connections with the NCBI servers, and leave you with an unfinished file :/ The only "
                              f"working solution so far is to try again with a faster internet connection.")

        progress.new(&quotFormatting protein ids to COG ids file&quot, progress_total_items=num_lines_in_file)

        p_id_to_cog_id = {}

        line_counter = 0
        for line in open(input_file_path, &quotrU&quot).readlines():
            line_counter += 1

            if line_counter % 500 == 0:
                self.progress.increment(line_counter)
                progress.update(f"{line_counter * 100 / num_lines_in_file:.2f}%")

            fields = line.strip(&quot\n&quot).split(&quot,&quot)

            &#47&#47 `p_id` should look just like the FASTA ids, and its location has changed between
            &#47&#47 2014 release and 2020 release.
            if self.COG_version == &quotCOG14&quot:
                try:
                    p_id = fields[0]
                    COG = fields[6]
                except Exception as e:
                    raise_error(line_counter, line, fields, e)
            elif self.COG_version == &quotCOG20&quot:
                try:
                    p_id = fields[2].replace(&quot.&quot, &quot_&quot)
                    COG = fields[6]
                except Exception as e:
                    raise_error(line_counter, line, fields, e)
            else:
                raise ConfigError("You need to edit all the if/else statements with COG version checks to ensure proper "
                                  "parsing of a new generation of COG files.")

            self.cogs_found_in_proteins_fasta.add(COG)

            if p_id in p_id_to_cog_id:
                if COG not in p_id_to_cog_id[p_id]:
                    p_id_to_cog_id[p_id].append(COG)
            else:
                p_id_to_cog_id[p_id] = [COG]

        progress.update("Serializing the data dictionary for future use (a.k.a, very pro stuff).")
        dictio.write_serialized_object(p_id_to_cog_id, output_file_path)

        progress.end()


    def format_cog_names(self, input_file_path, output_file_path):
        progress.new(&quotFormatting COG names file&quot)
        progress.update(&quot...&quot)
        output = open(output_file_path, &quotw&quot)

        try:
            lines = open(input_file_path).readlines()
        except UnicodeDecodeError:
            lines = open(input_file_path, encoding=&quotISO-8859-1&quot).readlines()

        for line in lines:
            if line.startswith(&quot&#47&#47&quot):
                continue

            if self.COG_version == &quotCOG14&quot:
                &#47&#47 example line from 2014:
                &#47&#47
                &#47&#47 COG0059 EH      Ketol-acid reductoisomerase
                COG, function, name = line.strip(&quot\n&quot).split(&quot\t&quot)
                name = &quot&quot.join([i if ord(i) &lt; 128 else &quot&quot for i in name])
                output.write(&quot\t&quot.join([COG, &quot, &quot.join(list(function)), name]) + &quot\n&quot)
            elif self.COG_version == &quotCOG20&quot:
                &#47&#47 example line from 2020:
                &#47&#47
                &#47&#47 COG0059	EH	Ketol-acid reductoisomerase	IlvC	Isoleucine, leucine, valine biosynthesis		1NP3
                COG, category, function, nn, pathway, pubmed_id, PDB_id = line.strip(&quot\n&quot).split(&quot\t&quot)

                function = &quot&quot.join([i if ord(i) &lt; 128 else &quot&quot for i in function])
                function = function if not nn else f"{function} ({nn})"
                function = function if not PDB_id else f"{function} (PDB:{PDB_id})"
                function = function if not pubmed_id else f"{function} (PUBMED:{pubmed_id})"

                output.write(&quot\t&quot.join([COG, &quot, &quot.join(list(category)), function, pathway]) + &quot\n&quot)

            else:
                raise ConfigError("You need to edit all the if/else statements with COG version checks to ensure proper "
                                  "parsing of a new generation of COG files.")

            self.cogs_found_in_cog_names_file.add(COG)
            progress.end()


    def format_categories(self, input_file_path, output_file_path):
        progress.new(&quotFormatting COG categories file&quot)
        progress.update(&quot...&quot)

        output = open(output_file_path, &quotw&quot)
        for line in open(input_file_path, &quotrU&quot).readlines():
            if line.startswith(&quot&#47&#47&quot):
                continue

            if self.COG_version == &quotCOG14&quot:
                category, description = line.strip(&quot\n&quot).split(&quot\t&quot)
            elif self.COG_version == &quotCOG20&quot:
                category, _, description = line.strip(&quot\n&quot).split(&quot\t&quot)
            else:
                raise ConfigError("You need to edit all the if/else statements with COG version checks to ensure proper "
                                  "parsing of a new generation of COG files.")

            &#47&#47 get rid of non-ascii chars:
            description = &quot&quot.join([i if ord(i) &lt; 128 else &quot&quot for i in description])

            output.write(&quot\t&quot.join([category, description]) + &quot\n&quot)

        progress.end()


    def format_protein_db(self, input_file_path, output_file_path):
        progress.new(&quotFormatting raw files&quot)
        progress.update(&quotDecompressing protein sequences&quot)

        &#47&#47 poor man&quots uncompress
        temp_fasta_path = filesnpaths.get_temp_file_path()
        try:
            with open(temp_fasta_path, &quotwb&quot) as f_out, gzip.open(input_file_path, &quotrb&quot) as f_in:
                f_out.write(f_in.read())
        except Exception as e:
            progress.end()
            raise ConfigError(f"Something went wrong while decompressing the downloaded file :/ It is likely that "
                              f"the download failed and only part of the file was downloaded. If you would like to "
                              f"try again, please run the setup command with the flag `--reset`. Here is what the "
                              f"downstream library said: &quot{e}&quot.")

        progress.end()

        if utils.is_program_exists(&quotdiamond&quot, dont_raise=True):
            output_dir = J(self.COG_data_dir, &quotDB_DIAMOND&quot)
            if os.path.exists(output_dir):
                shutil.rmtree(output_dir)

            os.mkdir(output_dir)

            output_db_path = J(output_dir, &quotCOG&quot)
            log_file_path = J(output_dir, &quotlog.txt&quot)

            self.run.info(&quotDiamond log&quot, log_file_path)

            diamond = Diamond(temp_fasta_path)
            diamond.num_threads = self.num_threads
            diamond.run.log_file_path = log_file_path
            diamond.makedb(output_db_path)
        else:
            self.run.warning("DIAMOND does not seem to be installed on this system, so anvi&quoto is not going to "
                             "generate a search database for it. Remember this when/if things go South.")

        if utils.is_program_exists(&quotmakeblastdb&quot, dont_raise=True) and utils.is_program_exists(&quotblastp&quot, dont_raise=True):
            output_dir = J(self.COG_data_dir, &quotDB_BLAST&quot)
            if os.path.exists(output_dir):
                shutil.rmtree(output_dir)

            os.mkdir(output_dir)

            output_db_path = J(output_dir, &quotCOG&quot)
            log_file_path = J(output_dir, &quotlog.txt&quot)

            self.run.info(&quotBLAST log&quot, log_file_path)

            blast = BLAST(temp_fasta_path)
            blast.run.log_file_path = log_file_path
            blast.num_threads = self.num_threads
            blast.makedb(os.path.join(output_db_path, &quotCOG.fa&quot))
        else:
            self.run.warning("BLAST tools do not seem to be installed on this system, so anvi&quoto is not going to "
                             "generate a search database for them to be used. Keep this in mind for later.")

        os.remove(temp_fasta_path)


    def get_raw_data(self):
        if not os.path.exists(self.raw_NCBI_files_dir):
            os.mkdir(self.raw_NCBI_files_dir)
            open(self.COG_data_dir_version, &quotw&quot).write(COG_DATA_VERSION)

        for file_name in self.files:
            if not &quoturl&quot in self.files[file_name]:
                continue

            file_path = J(self.raw_NCBI_files_dir, file_name)
            if not os.path.exists(file_path):
                utils.download_file(self.files[file_name][&quoturl&quot], file_path, progress=progress, run=run)


    def setup_raw_data(self):
        for file_name in self.files:
            file_path = J(self.raw_NCBI_files_dir, file_name)

            if not &quotfunc&quot in self.files[file_name]:
                continue

            if not os.path.exists(file_path):
                raise ConfigError("Something is wrong :/ Raw files are not in place...")

            self.files[file_name][&quotfunc&quot](file_path, J(self.COG_data_dir, self.files[file_name][&quotformatted_file_name&quot]))
</code></pre>