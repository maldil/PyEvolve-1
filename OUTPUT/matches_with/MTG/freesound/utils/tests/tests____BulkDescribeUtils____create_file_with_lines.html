<link rel="stylesheet" href="../../../..//default.css">
<script src="../../../..//highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><pre><code class='java'>
<a href="https://github.com/MTG/freesound/blob/master/utils/tests/tests.py#L224">GitHubLink</a>


<a href="https://github.com/maldil/freesound/blob/master/utils/tests/tests.py#L224">GitMyHubLink</a>

&#47&#47
&#47&#47 Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
&#47&#47
&#47&#47 Freesound is free software: you can redistribute it and/or modify
&#47&#47 it under the terms of the GNU Affero General Public License as
&#47&#47 published by the Free Software Foundation, either version 3 of the
&#47&#47 License, or (at your option) any later version.
&#47&#47
&#47&#47 Freesound is distributed in the hope that it will be useful,
&#47&#47 but WITHOUT ANY WARRANTY; without even the implied warranty of
&#47&#47 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
&#47&#47 GNU Affero General Public License for more details.
&#47&#47
&#47&#47 You should have received a copy of the GNU Affero General Public License
&#47&#47 along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
&#47&#47
&#47&#47 Authors:
&#47&#47     See AUTHORS file.
&#47&#47

import datetime
import os
import shutil

import mock
from django.conf import settings
from django.contrib.auth.models import User
from django.core.cache import cache
from django.test import TestCase, override_settings
from django.urls import reverse

import utils.downloads
from donations.models import Donation, DonationsModalSettings
from sounds.models import Sound, Pack, License, Download
from utils.audioprocessing.freesound_audio_processing import FreesoundAudioProcessor
from utils.audioprocessing.processing import AudioProcessingException
from utils.filesystem import create_directories
from utils.sound_upload import get_csv_lines, validate_input_csv_file, bulk_describe_from_csv, create_sound, \
    NoAudioException, AlreadyExistsException
from utils.tags import clean_and_split_tags
from utils.test_helpers import create_test_files, create_user_and_sounds, override_uploads_path_with_temp_directory, \
    override_csv_path_with_temp_directory, override_sounds_path_with_temp_directory, \
    override_previews_path_with_temp_directory, override_displays_path_with_temp_directory, \
    override_analysis_path_with_temp_directory, override_processing_tmp_path_with_temp_directory


class UtilsTest(TestCase):

    fixtures = [&quotlicenses&quot, &quotuser_groups&quot, &quotmoderation_queues&quot]

    def test_download_sounds(self):
        user = User.objects.create_user("testuser", password="testpass")
        pack = Pack.objects.create(user=user, name="Test pack")
        for i in range(0, 5):
            Sound.objects.create(
                user=user,
                original_filename="Test sound %i" % i,
                base_filename_slug="test_sound_%i" % i,
                license=License.objects.all()[0],
                pack=pack,
                md5="fakemd5_%i" % i)
        licenses_url = (reverse(&quotpack-licenses&quot, args=["testuser", pack.id]))
        ret = utils.downloads.download_sounds(licenses_url, pack)
        self.assertEqual(ret.status_code, 200)

    @override_uploads_path_with_temp_directory
    def test_upload_sounds(self):
        &#47&#47 create new sound files
        filenames = [&quotfile1.wav&quot, &quotfile2.wav&quot]
        user = User.objects.create_user("testuser", password="testpass")
        user_upload_path = settings.UPLOADS_PATH + &quot/%i/&quot % user.id
        create_directories(user_upload_path)
        create_test_files(filenames, user_upload_path)
        shutil.copyfile(user_upload_path + filenames[0], user_upload_path + "copy.wav")
        license = License.objects.all()[0]
        sound_fields = {
            &quotname&quot: &quotnew sound&quot,
            &quotdest_path&quot: user_upload_path + filenames[0],
            &quotlicense&quot: license.name,
            &quotdescription&quot: &quotnew sound&quot,
            &quottags&quot: clean_and_split_tags(&quottag1, tag2, tag3&quot),
        }
        create_sound(user, sound_fields, process=False)
        self.assertEqual(user.sounds.all().count(), 1)

        &#47&#47 Now the file has been removed so it should fail
        try:
            create_sound(user, sound_fields, process=False)
        except NoAudioException:
            &#47&#47 If we try to upload the same file again it shuld also fail
            sound_fields[&quotdest_path&quot] = user_upload_path + "copy.wav"
            try:
                create_sound(user, sound_fields, process=False)
            except AlreadyExistsException:
                pass
        self.assertEqual(user.sounds.all().count(), 1)

        &#47&#47 Upload file with geotag and pack
        sound_fields[&quotdest_path&quot] = user_upload_path + filenames[1]
        sound_fields[&quotgeotag&quot] = &quot41.2222,31.0000,17&quot
        sound_fields[&quotpack&quot] = &quotnew pack&quot
        sound_fields[&quotname&quot] = filenames[1]
        create_sound(user, sound_fields, process=False)
        self.assertEqual(user.sounds.all().count(), 2)
        self.assertEqual(Pack.objects.filter(name=&quotnew pack&quot).exists(), True)
        self.assertEqual(user.sounds.get(original_filename=filenames[1]).tags.count(), 3)
        self.assertNotEqual(user.sounds.get(original_filename=filenames[1]).geotag, None)


class ShouldSuggestDonationTest(TestCase):

    fixtures = [&quotlicenses&quot]

    def test_should_suggest_donation_probabilty_1(self):

        &#47&#47 In this set of tests &quotshould_suggest_donation&quot should return True or False depending on the decided criteria
        &#47&#47 Probabilty is set to 1.0 to avoid ranomeness in the test
        donations_settings, _ = DonationsModalSettings.objects.get_or_create()
        donations_settings.display_probability = 1.0
        donations_settings.save()
        cache.set(DonationsModalSettings.DONATION_MODAL_SETTINGS_CACHE_KEY, donations_settings, timeout=3600)

        user = User.objects.create_user("testuser", password="testpass")

        &#47&#47 should_suggest_donation returns False if modal has been shown more than DONATION_MODAL_DISPLAY_TIMES_DAY
        times_shown_in_last_day = donations_settings.max_times_display_a_day + 1
        self.assertEqual(utils.downloads.should_suggest_donation(user, times_shown_in_last_day), False)

        &#47&#47 set times_shown_in_last_day lower than DONATION_MODAL_DISPLAY_TIMES_DAY
        times_shown_in_last_day = donations_settings.max_times_display_a_day - 1

        &#47&#47 if user donated recently, modal is not shown (even if times_shown_in_last_day &lt;
        &#47&#47 DONATION_MODAL_DISPLAY_TIMES_DAY)
        donation = Donation.objects.create(user=user, amount=1)
        self.assertEqual(utils.downloads.should_suggest_donation(user, times_shown_in_last_day), False)

        &#47&#47 remove donation object (to simulate user never donated)
        donation.delete()

        &#47&#47 if user has downloaded less or equal than donations_settings.downloads_in_period, do not show the modal
        sound = Sound.objects.create(
            user=user,
            original_filename="Test sound",
            base_filename_slug="test_sound_10",
            license=License.objects.all()[0],
            md5="fakemd5_10")
        for i in range(0, donations_settings.downloads_in_period):
            Download.objects.create(user=user, sound=sound, license=License.objects.first())
            self.assertEqual(utils.downloads.should_suggest_donation(user, times_shown_in_last_day), False)
        Download.objects.create(user=user, sound=sound, license=License.objects.first())  &#47&#47 downloads &gt; donations_settings.downloads_in_period (modal shows)
        self.assertEqual(utils.downloads.should_suggest_donation(user, times_shown_in_last_day), True)

        &#47&#47 if the download objects are older than donations_settings.download_days, don&quott consider them
        Download.objects.filter(user=user).update(
            created=datetime.datetime.now()-datetime.timedelta(days=donations_settings.download_days + 1))
        self.assertEqual(utils.downloads.should_suggest_donation(user, times_shown_in_last_day), False)

        &#47&#47 if user has donations but these are older than donations_settings.days_after_donation, do not consider them
        Donation.objects.create(user=user, amount=1)
        Donation.objects.filter(user=user).update(
            created=datetime.datetime.now()-datetime.timedelta(days=donations_settings.days_after_donation + 1))
        Download.objects.filter(user=user).update(
            created=datetime.datetime.now())  &#47&#47 Change downloads date again to be recent (modal show be shown)
        self.assertEqual(utils.downloads.should_suggest_donation(user, times_shown_in_last_day), True)

    def test_should_suggest_donation_probabilty_0(self):
        &#47&#47 In this set of tests &quotshould_suggest_donation&quot should always return False as probability is set to 0.0
        donations_settings, _ = DonationsModalSettings.objects.get_or_create()
        donations_settings.display_probability = 0.0
        donations_settings.save()
        cache.set(DonationsModalSettings.DONATION_MODAL_SETTINGS_CACHE_KEY, donations_settings, timeout=3600)

        user = User.objects.create_user("testuser", password="testpass")

        &#47&#47 should_suggest_donation returns False if modal has been shown more than DONATION_MODAL_DISPLAY_TIMES_DAY
        times_shown_in_last_day = donations_settings.max_times_display_a_day + 1
        self.assertEqual(utils.downloads.should_suggest_donation(user, times_shown_in_last_day), False)

        &#47&#47 set times_shown_in_last_day lower than DONATION_MODAL_DISPLAY_TIMES_DAY
        times_shown_in_last_day = donations_settings.max_times_display_a_day - 1

        &#47&#47 if user donated recently, modal is not shown (even if times_shown_in_last_day &lt;
        &#47&#47 DONATION_MODAL_DISPLAY_TIMES_DAY)
        donation = Donation.objects.create(user=user, amount=1)
        self.assertEqual(utils.downloads.should_suggest_donation(user, times_shown_in_last_day), False)

        &#47&#47 remove donation object (to simulate user never donated)
        donation.delete()

        &#47&#47 if user has downloaded less or equal than donations_settings.downloads_in_period, do not show the modal
        sound = Sound.objects.create(
            user=user,
            original_filename="Test sound",
            base_filename_slug="test_sound_10",
            license=License.objects.all()[0],
            md5="fakemd5_10")
        for i in range(0, donations_settings.downloads_in_period):
            Download.objects.create(user=user, sound=sound, license=License.objects.first())
            self.assertEqual(utils.downloads.should_suggest_donation(user, times_shown_in_last_day), False)
        Download.objects.create(user=user, sound=sound, license=License.objects.first())  &#47&#47 n downloads &gt; donations_settings.downloads_in_period
        &#47&#47 In this case still not shown the modal as probability is 0.0
        self.assertEqual(utils.downloads.should_suggest_donation(user, times_shown_in_last_day), False)

        &#47&#47 if the download objects are older than donations_settings.download_days, don&quott consider them
        Download.objects.filter(user=user).update(
            created=datetime.datetime.now() - datetime.timedelta(days=donations_settings.download_days + 1))
        self.assertEqual(utils.downloads.should_suggest_donation(user, times_shown_in_last_day), False)

        &#47&#47 if user has donations but these are older than donations_settings.days_after_donation, do not consider them
        Donation.objects.create(user=user, amount=1)
        Donation.objects.filter(user=user).update(
            created=datetime.datetime.now() - datetime.timedelta(days=donations_settings.days_after_donation + 1))
        Download.objects.filter(user=user).update(
            created=datetime.datetime.now())
        &#47&#47 Change downloads date again to be recent (however modal won&quott show because probability is 0.0)
        self.assertEqual(utils.downloads.should_suggest_donation(user, times_shown_in_last_day), False)


class BulkDescribeUtils(TestCase):

    fixtures = [&quotlicenses&quot]

    @staticmethod
    def create_file_with_lines(filename, lines, base_path):
        <a id="change">csv_file_path</a> = &quot%s/%s&quot % (base_path, filename)
        <a id="change">csv_fid</a><a id="change"> = open(csv_file_path, &quotw&quot)</a>
        for <a id="change">line</a> in lines:
            csv_fid.write(line + &quot\n&quot)
        <a id="change">csv_fid</a><a id="change">.close()</a>
        return csv_file_path

    def test_get_csv_lines(self):
        &#47&#47 Load sample files for CSV, XLS and XLSX formats and compare the output of reading them is the same
        sample_csv_path = os.path.join(settings.MEDIA_ROOT, &quotsample.csv&quot)
        sample_xls_path = os.path.join(settings.MEDIA_ROOT, &quotsample.xls&quot)
        sample_xlsx_path = os.path.join(settings.MEDIA_ROOT, &quotsample.xlsx&quot)
        header_csv, lines_csv = get_csv_lines(sample_csv_path)
        header_xls, lines_xls = get_csv_lines(sample_xls_path)
        header_xlsx, lines_xlsx = get_csv_lines(sample_xlsx_path)

        for i in range(0, len(header_csv)):
            &#47&#47 Check headers have the same value
            self.assertTrue(header_csv[i] == header_xls[i] == header_xlsx[i])

            &#47&#47 Check lines from all formats parse same value for specific header value
            header_value = header_csv[i]
            for j in range(0, len(lines_csv)):
                if header_value == &quotis_explicit&quot:
                    &#47&#47 NOTE: Excel treats all numbers as floats, therefore for comparing rows that have numbers we
                    &#47&#47 first convert them all to float.
                    self.assertTrue(
                        float(lines_csv[j][header_value]) ==
                        float(lines_xls[j][header_value]) ==
                        float(lines_xlsx[j][header_value]))
                else:
                    self.assertTrue(
                        lines_csv[j][header_value] ==
                        lines_xls[j][header_value] ==
                        lines_xlsx[j][header_value])

        &#47&#47 NOTE: more advance testing of this funciton would mean testing with different types of "good" and "bad" files
        &#47&#47 for each of the formats. For the CSV case that would rather feasible as we can generate the files
        &#47&#47 programatically. For the XLS and XLSX case we would need to rely on a third-party library to create XLS and
        &#47&#47 XLSX files which would only be used for that. In any of the cases, we will never cover the myriard of
        &#47&#47 evil CSV/XLS/XLSX files that can be out there. I think it is better to make sure that in case of unexpected
        &#47&#47 error we show that message to the users instead of trying to cover all possible errors.

    @override_uploads_path_with_temp_directory
    @override_csv_path_with_temp_directory
    def test_validate_input_csv_file(self):
        &#47&#47 Create user uploads folder and test audio files
        user = User.objects.create_user("testuser", password="testpass")
        user_upload_path = settings.UPLOADS_PATH + &quot/%i/&quot % user.id
        create_directories(user_upload_path)
        create_test_files([&quotfile1.wav&quot, &quotfile2.wav&quot, &quotfile3.wav&quot, &quotfile4.wav&quot, &quotfile5.wav&quot], user_upload_path)

        &#47&#47 Create CSV files folder with descriptions
        csv_file_base_path = settings.CSV_PATH + &quot/%i/&quot % user.id
        create_directories(csv_file_base_path)

        &#47&#47 Test CSV with all lines and metadata ok
        csv_file_path = self.create_file_with_lines(&quottest_descriptions.csv&quot, [
            &quotaudio_filename,name,tags,geotag,description,license,pack_name,is_explicit&quot,
            &quotfile1.wav,New name for file1.wav,"tag1 tag2 tag3","41.4065, 2.19504, 23",&quot
            &quot"Description for file",Creative Commons 0,ambient,0&quot,  &#47&#47 All fields valid
            &quotfile2.wav,,"tag1 tag2 tag3",,"Description for file",Creative Commons 0,,0&quot,  &#47&#47 Only mandatory fields
            &quotfile3.wav,,"tag1 tag2 tag3",,&quot
            &quot"Description for file",Creative Commons 0,ambient,1&quot,  &#47&#47 All mandatory fields and some optional fields
        ], csv_file_base_path)
        header, lines = get_csv_lines(csv_file_path)
        lines_validated, global_errors = \
            validate_input_csv_file(header, lines, user_upload_path, username=user.username)
        self.assertEqual(len(global_errors), 0)  &#47&#47 No global errors
        self.assertEqual(len([line for line in lines_validated if line[&quotline_errors&quot]]), 0)  &#47&#47 No line errors

        &#47&#47 Test username does not exist
        lines_validated, global_errors = \
            validate_input_csv_file(header, lines, user_upload_path, username="unexisting username")
        self.assertEqual(len(global_errors), 0)  &#47&#47 No global errors
        self.assertEqual(len([line for line in lines_validated if line[&quotline_errors&quot]]), 3)  &#47&#47 Three line errors
        self.assertTrue(&quotusername&quot in lines_validated[0][&quotline_errors&quot])  &#47&#47 User does not exist error reported
        self.assertTrue(&quotusername&quot in lines_validated[1][&quotline_errors&quot])  &#47&#47 User does not exist error reported
        self.assertTrue(&quotusername&quot in lines_validated[2][&quotline_errors&quot])  &#47&#47 User does not exist error reported

        &#47&#47 Test missing/duplicated audiofile and wrong number of rows
        csv_file_path = self.create_file_with_lines(&quottest_descriptions.csv&quot, [
            &quotaudio_filename,name,tags,geotag,description,license,pack_name,is_explicit&quot,
            &quotfile1.wav,,"tag1 tag2 tag3",,"Description for file",Creative Commons 0,,1&quot,  &#47&#47 File exists, fields ok
            &quotfile2.wav,,"tag1 tag2 tag3",,,Creative Commons 0,,1&quot,  &#47&#47 Missing description
            &quotfile3.wav,,"tag1 tag2 tag3",,"Description for file",,1&quot,  &#47&#47 Wrong number of columns
            &quotfile6.wav,,"tag1 tag2 tag3",,"Description for file",Creative Commons 0,,1&quot,  &#47&#47 Audiofile does not exist
            &quotfile2.wav,,"tag1 tag2 tag3",,"Description for file",Creative Commons 0,,1&quot,  &#47&#47 Audiofile already described
        ], csv_file_base_path)
        header, lines = get_csv_lines(csv_file_path)
        lines_validated, global_errors = \
            validate_input_csv_file(header, lines, user_upload_path, username=user.username)
        self.assertEqual(len(global_errors), 0)  &#47&#47 No global errors
        self.assertEqual(len([line for line in lines_validated if line[&quotline_errors&quot]]), 4)  &#47&#47 Four lines have errors
        self.assertTrue(&quotdescription&quot in lines_validated[1][&quotline_errors&quot])  &#47&#47 Missing description error reported
        self.assertTrue(&quotcolumns&quot in lines_validated[2][&quotline_errors&quot])  &#47&#47 Wrong number of columns reported
        self.assertTrue(&quotaudio_filename&quot in lines_validated[3][&quotline_errors&quot])  &#47&#47 Audiofile not exist error reported
        self.assertTrue(&quotaudio_filename&quot in lines_validated[4][&quotline_errors&quot])  &#47&#47 File already described error reported

        &#47&#47 Test validation errors in individual fields
        csv_file_path = self.create_file_with_lines(&quottest_descriptions.csv&quot, [
            &quotaudio_filename,name,tags,geotag,description,license,pack_name,is_explicit&quot,
            &quotfile1.wav,,"tag1 tag2",,"Description for file",Creative Commons 0,,1&quot,  &#47&#47 Wrong tags (less than 3)
            &quotfile2.wav,,"tag1,tag2",,"Description for file",Creative Commons 0,,1&quot,  &#47&#47 Wrong tags (less than 3)
            &quotfile3.wav,,"tag1,tag2",gr87g,"Description for file2",Creative Commons 0,,1&quot,  &#47&#47 Wrong geotag
            &quotfile4.wav,,"tag1,tag2",42.34,190.45,15,"Description for file",Creative Commons 0,,1&quot,  &#47&#47 Wrong geotag
            &quotfile5.wav,,"tag1 tag2 tag3",,"Description for file",Sampling+,,1&quot,  &#47&#47 Invalid license
            &quotfile6.wav,,"tag1 tag2 tag3",,"Description for file",Sampling+,,rt&quot,  &#47&#47 Invalid is_explicit
        ], csv_file_base_path)
        header, lines = get_csv_lines(csv_file_path)
        lines_validated, global_errors = \
            validate_input_csv_file(header, lines, user_upload_path, username=user.username)
        self.assertEqual(len(global_errors), 0)  &#47&#47 No global errors
        self.assertEqual(len([line for line in lines_validated if line[&quotline_errors&quot]]), 6)  &#47&#47 Six lines have errors
        self.assertTrue(&quottags&quot in lines_validated[0][&quotline_errors&quot])  &#47&#47 Wrong tags
        self.assertTrue(&quottags&quot in lines_validated[1][&quotline_errors&quot])  &#47&#47 Wrong tags
        self.assertTrue(&quotgeotag&quot in lines_validated[2][&quotline_errors&quot])  &#47&#47 Wrong geotag
        self.assertTrue(&quotgeotag&quot in lines_validated[3][&quotline_errors&quot])  &#47&#47 Wrong geotag
        self.assertTrue(&quotlicense&quot in lines_validated[4][&quotline_errors&quot])  &#47&#47 Wrong license
        self.assertTrue(&quotis_explicit&quot in lines_validated[5][&quotline_errors&quot])  &#47&#47 Wrong is_explicit

        &#47&#47 Test wrong header global errors
        csv_file_path = self.create_file_with_lines(&quottest_descriptions.csv&quot, [
            &quotaudio_filename,name,tags,geotag,description,license,unknown_field&quot,
        ], csv_file_base_path)
        header, lines = get_csv_lines(csv_file_path)
        lines_validated, global_errors = \
            validate_input_csv_file(header, lines, user_upload_path, username=user.username)
        self.assertEqual(len(global_errors), 2)  &#47&#47 Two global errors
        self.assertTrue(&quotInvalid header&quot in global_errors[0])  &#47&#47 Invalid header error reported
        self.assertTrue(&quotno lines with sound&quot in global_errors[1])  &#47&#47 No sounds in csv file error reported

        csv_file_path = self.create_file_with_lines(&quottest_descriptions.csv&quot, [
            &quotaudio_filename,name,tags,geotag,description,license,pack_name,is_explicit&quot,
        ], csv_file_base_path)
        header, lines = get_csv_lines(csv_file_path)
        lines_validated, global_errors = \
            validate_input_csv_file(header, lines, user_upload_path,
                                    username=None)  &#47&#47 Not passing username, header should now include &quotusername&quot field
        self.assertEqual(len(global_errors), 2)  &#47&#47 One global error
        self.assertTrue(&quotInvalid header&quot in global_errors[0])  &#47&#47 Invalid header error reported
        self.assertTrue(&quotno lines with sound&quot in global_errors[1])  &#47&#47 No sounds in csv file error reported

        csv_file_path = self.create_file_with_lines(&quottest_descriptions.csv&quot, [
            &quotaudio_filename,name,tags,geotag,description,license,pack_name,is_explicit,username&quot,
        ], csv_file_base_path)
        header, lines = get_csv_lines(csv_file_path)
        lines_validated, global_errors = \
            validate_input_csv_file(header, lines, user_upload_path,
                                    username=None)  &#47&#47 Not passing username, header should now include &quotusername&quot field
        self.assertEqual(len(global_errors), 1)  &#47&#47 One global error
        self.assertTrue(&quotno lines with sound&quot in global_errors[0])  &#47&#47 No sounds in csv file error reported

        &#47&#47 Test username errors when not passing username argument to validate_input_csv_file
        csv_file_path = self.create_file_with_lines(&quottest_descriptions.csv&quot, [
            &quotaudio_filename,name,tags,geotag,description,license,pack_name,is_explicit,username&quot,
            &quotfile1.wav,,"tag1 tag2 tag3",,"Description for file",Creative Commons 0,,1,new_username&quot,  &#47&#47 User does not exist
            &quotfile2.wav,,"tag1 tag2 tag3",,"Description for file",Creative Commons 0,,1&quot,  &#47&#47 Invlaid num columns
            &quotfile3.wav,,"tag1 tag2 tag3",,"Description for file",Creative Commons 0,,0,testuser&quot,  &#47&#47 All fields OK
        ], csv_file_base_path)
        header, lines = get_csv_lines(csv_file_path)
        lines_validated, global_errors = validate_input_csv_file(header, lines, user_upload_path, username=None)
        self.assertEqual(len(global_errors), 0)  &#47&#47 No global errors
        self.assertEqual(len([line for line in lines_validated if line[&quotline_errors&quot]]), 2)  &#47&#47 Two lines have errors
        self.assertTrue(&quotusername&quot in lines_validated[0][&quotline_errors&quot])  &#47&#47 User does not exist
        self.assertTrue(&quotcolumns&quot in lines_validated[1][&quotline_errors&quot])  &#47&#47 Invalid number of columns

    @override_uploads_path_with_temp_directory
    @override_csv_path_with_temp_directory
    def test_bulk_describe_from_csv(self):

        &#47&#47 Create user uploads folder and test audio files
        user = User.objects.create_user("testuser", password="testpass")
        user_upload_path = settings.UPLOADS_PATH + &quot/%i/&quot % user.id
        create_directories(user_upload_path)
        create_test_files([&quotfile1.wav&quot, &quotfile2.wav&quot, &quotfile3.wav&quot, &quotfile4.wav&quot, &quotfile5.wav&quot], user_upload_path)

        &#47&#47 Create CSV files folder with descriptions
        csv_file_base_path = settings.CSV_PATH + &quot/%i/&quot % user.id
        create_directories(csv_file_base_path)

        &#47&#47 Create Test CSV with some lines ok and some wrong lines
        csv_file_path = self.create_file_with_lines(&quottest_descriptions.csv&quot, [
            &quotaudio_filename,name,tags,geotag,description,license,pack_name,is_explicit&quot,
            &quotfile1.wav,,"tag1 tag2 tag3","41.4065, 2.19504, 23","Description for file",Creative Commons 0,ambient,1&quot,  &#47&#47 OK
            &quotfile2.wav,,"tag1 tag2 tag3",,"Description for file",Invalid license,,1&quot,  &#47&#47 Invalid license
            &quotfile3.wav,,"tag1 tag2 tag3",,"Description for file",Creative Commons 0,1&quot,  &#47&#47 Wrong number of columns
            &quotfile4.wav,,"tag1 tag2 tag3",dg,"Description for file",Creative Commons 0,,0&quot,  &#47&#47 Invalid geotag
            &quotfile5.wav,,"tag1 tag2 tag3",,"Description for file",Creative Commons 0,,0&quot,  &#47&#47 OK
        ], csv_file_base_path)

        &#47&#47 Test case when no sounds are been created because CSV file has some errors and &quotforce_import&quot is set to False
        bulk_describe_from_csv(csv_file_path,
                               delete_already_existing=False,
                               force_import=False,
                               sounds_base_dir=user_upload_path,
                               username=user.username)
        self.assertEqual(user.sounds.count(), 0)  &#47&#47 User has no sounds

        &#47&#47 Test case using &quotforce_import&quot (only sounds for lines that validate ok will be created)
        bulk_describe_from_csv(csv_file_path,
                               delete_already_existing=False,
                               force_import=True,
                               sounds_base_dir=user_upload_path,
                               username=user.username)
        self.assertEqual(user.sounds.count(), 2)  &#47&#47 The two sounds that had correct metadata have been added
        sound1 = Sound.objects.get(user=user, original_filename=&quotfile1.wav&quot)  &#47&#47 Get first correct sound
        sound1_id = sound1.id  &#47&#47 This is used in a test below
        self.assertTrue(sound1.geotag)  &#47&#47 Check sound has geotag object assigned
        self.assertEqual(sound1.pack.name, &quotambient&quot)  &#47&#47 Check sound has pack and name of pack is &quotambient&quot
        sound2 = Sound.objects.get(user=user, original_filename=&quotfile5.wav&quot)  &#47&#47 Get last correct sound
        sound2_id = sound2.id  &#47&#47 This is used in a test below
        self.assertIsNone(sound2.geotag)  &#47&#47 Check sound has no geotag
        self.assertIsNone(sound2.pack)  &#47&#47 Check sound has no pack

        &#47&#47 Run again using &quotforce_import&quot and sounds won&quott be created because sounds already exist and md5 check fails
        &#47&#47 NOTE: first we copy back the files that were already successfully added because otherwise these don&quott exist
        shutil.copy(sound1.locations()[&quotpath&quot], os.path.join(user_upload_path, &quotfile1.wav&quot))
        shutil.copy(sound2.locations()[&quotpath&quot], os.path.join(user_upload_path, &quotfile5.wav&quot))
        bulk_describe_from_csv(csv_file_path,
                               delete_already_existing=False,
                               force_import=True,
                               sounds_base_dir=user_upload_path,
                               username=user.username)
        self.assertEqual(user.sounds.count(), 2)  &#47&#47 User still has two sounds, no new sounds added

        &#47&#47 Run again using &quotforce_import&quot AND &quotdelete_already_existing&quot and existing sounds will be removed before
        &#47&#47 creating the new ones
        &#47&#47 NOTE: first we copy back the files that failed MD5 check as files are discarted (deleted) when MD5 fails
        shutil.copy(sound1.locations()[&quotpath&quot], os.path.join(user_upload_path, &quotfile1.wav&quot))
        shutil.copy(sound2.locations()[&quotpath&quot], os.path.join(user_upload_path, &quotfile5.wav&quot))
        bulk_describe_from_csv(csv_file_path,
                               delete_already_existing=True,
                               force_import=True,
                               sounds_base_dir=user_upload_path,
                               username=user.username)
        self.assertEqual(user.sounds.count(), 2)  &#47&#47 User still has two sounds
        new_sound1 = Sound.objects.get(user=user, original_filename=&quotfile1.wav&quot)  &#47&#47 New version of first correct sound
        new_sound2 = Sound.objects.get(user=user, original_filename=&quotfile5.wav&quot)  &#47&#47 New version of last correct sound
        self.assertNotEqual(new_sound1.id, sound1_id)  &#47&#47 Check that IDs are not the same
        self.assertNotEqual(new_sound2.id, sound2_id)  &#47&#47 Check that IDs are not the same


def convert_to_pcm_mock(input_filename, output_filename):
    return True


def convert_to_pcm_mock_create_file(input_filename, output_filename):
    create_test_files(paths=[output_filename], n_bytes=2048)
    return True


def convert_to_pcm_mock_fail(input_filename, output_filename):
    raise AudioProcessingException("failed converting to pcm")


def stereofy_mock(stereofy_executble_path, input_filename, output_filename):
    return dict(
        duration=123.5,
        channels=2,
        samplerate=44100,
        bitdepth=16)


def stereofy_mock_fail(stereofy_executble_path, input_filename, output_filename):
    raise AudioProcessingException("stereofy has failed")


def convert_to_mp3_mock(input_filename, output_filename, quality):
    create_test_files(paths=[output_filename])


def convert_to_mp3_mock_fail(input_filename, output_filename, quality):
    raise AudioProcessingException("conversion to mp3 (preview) has failed")


def convert_to_ogg_mock(input_filename, output_filename, quality):
    create_test_files(paths=[output_filename])


def convert_to_ogg_mock_fail(input_filename, output_filename, quality):
    raise AudioProcessingException("conversion to ogg (preview) has failed")


def create_wave_images_mock(
        input_filename, output_filename_w, output_filename_s, image_width, image_height, fft_size, **kwargs):
    create_test_files(paths=[output_filename_w, output_filename_s])


def create_wave_images_mock_fail(
        input_filename, output_filename_w, output_filename_s, image_width, image_height, fft_size, **kwargs):
    raise AudioProcessingException("creation of display images has failed")


class AudioProcessingTestCase(TestCase):

    fixtures = [&quotlicenses&quot]

    def pre_test(self, create_sound_file=True):
        &#47&#47 Do some stuff which needs to be carried out right before each test
        self.assertEqual(self.sound.processing_state, "PE")
        if create_sound_file:
            create_test_files(paths=[self.sound.locations(&quotpath&quot)])  &#47&#47 Create fake file for original sound path

    def setUp(self):
        user, _, sounds = create_user_and_sounds(num_sounds=1, type="mp3")  &#47&#47 Use mp3 so it needs converstion to PCM
        self.sound = sounds[0]
        self.user = user

    def test_sound_object_does_not_exist(self):
        with self.assertRaises(AudioProcessingException) as cm:
            FreesoundAudioProcessor(sound_id=999)
        exc = cm.exception
        self.assertIn(&quotdid not find Sound object&quot, exc.message)

    @override_settings(USE_PREVIEWS_WHEN_ORIGINAL_FILES_MISSING=False)
    @override_processing_tmp_path_with_temp_directory
    def test_sound_path_does_not_exist(self):
        self.pre_test(create_sound_file=False)
        result = FreesoundAudioProcessor(sound_id=Sound.objects.first().id).process()
        self.assertFalse(result)  &#47&#47 Processing failed, retutned False
        self.sound.refresh_from_db()
        self.assertEqual(self.sound.processing_state, "FA")
        self.assertEqual(self.sound.processing_ongoing_state, "FI")
        self.assertIn(&quotcould not find file with path&quot, self.sound.processing_log)
        self.assertFalse(len(os.listdir(settings.PROCESSING_TEMP_DIR)), 0)

    @mock.patch(&quotutils.audioprocessing.processing.convert_to_pcm&quot, side_effect=convert_to_pcm_mock_fail)
    @override_settings(USE_PREVIEWS_WHEN_ORIGINAL_FILES_MISSING=False)
    @override_processing_tmp_path_with_temp_directory
    @override_sounds_path_with_temp_directory
    def test_conversion_to_pcm_failed(self, *args):
        self.pre_test()
        result = FreesoundAudioProcessor(sound_id=Sound.objects.first().id).process()
        &#47&#47 will fail because mocked version of convert_to_pcm fails
        self.assertFalse(result)  &#47&#47 Processing failed, retutned False
        self.sound.refresh_from_db()
        self.assertEqual(self.sound.processing_state, "FA")
        self.assertEqual(self.sound.processing_ongoing_state, "FI")
        self.assertIn(&quotconversion to PCM failed&quot, self.sound.processing_log)
        self.assertFalse(len(os.listdir(settings.PROCESSING_TEMP_DIR)), 0)

    @override_settings(USE_PREVIEWS_WHEN_ORIGINAL_FILES_MISSING=False)
    @override_processing_tmp_path_with_temp_directory
    @override_sounds_path_with_temp_directory
    def test_no_need_to_convert_to_pcm(self):
        self.sound.type = &quotwav&quot
        self.sound.save()
        self.pre_test()
        result = FreesoundAudioProcessor(sound_id=Sound.objects.first().id).process()
        self.assertFalse(result)  &#47&#47 Processing failed, retutned False
        self.sound.refresh_from_db()
        self.assertEqual(self.sound.processing_state, "FA")
        self.assertEqual(self.sound.processing_ongoing_state, "FI")
        self.assertIn(&quotno need to convert, this file is already PCM data&quot, self.sound.processing_log)
        self.assertFalse(len(os.listdir(settings.PROCESSING_TEMP_DIR)), 0)
        &#47&#47 NOTE: this test will generate stereofy errors as well but here we only check that a spcific message about
        &#47&#47 PCM conversion was added to the log. stereofy is tested below.

    @mock.patch(&quotutils.audioprocessing.processing.stereofy_and_find_info&quot, side_effect=stereofy_mock_fail)
    @mock.patch(&quotutils.audioprocessing.processing.convert_to_pcm&quot, side_effect=convert_to_pcm_mock)
    @override_settings(USE_PREVIEWS_WHEN_ORIGINAL_FILES_MISSING=False)
    @override_processing_tmp_path_with_temp_directory
    @override_sounds_path_with_temp_directory
    def test_stereofy_failed(self, *args):
        self.pre_test()
        result = FreesoundAudioProcessor(sound_id=Sound.objects.first().id).process()
        &#47&#47 processing will fail because stereofy mock raises an exception
        self.assertFalse(result)  &#47&#47 Processing failed, retutned False
        self.sound.refresh_from_db()
        self.assertEqual(self.sound.processing_state, "FA")
        self.assertEqual(self.sound.processing_ongoing_state, "FI")
        self.assertIn(&quotstereofy has failed&quot, self.sound.processing_log)
        self.assertFalse(len(os.listdir(settings.PROCESSING_TEMP_DIR)), 0)

    @mock.patch(&quotutils.audioprocessing.processing.stereofy_and_find_info&quot, side_effect=stereofy_mock)
    @mock.patch(&quotutils.audioprocessing.processing.convert_to_pcm&quot, side_effect=convert_to_pcm_mock)
    @override_settings(USE_PREVIEWS_WHEN_ORIGINAL_FILES_MISSING=False)
    @override_processing_tmp_path_with_temp_directory
    @override_sounds_path_with_temp_directory
    def test_set_audio_info_fields(self, *args):
        self.pre_test()
        FreesoundAudioProcessor(sound_id=Sound.objects.first().id).process()
        self.sound.refresh_from_db()
        self.assertEqual(self.sound.duration, 123.5)  &#47&#47 Assert that info properties were set
        self.assertEqual(self.sound.channels, 2)
        self.assertEqual(self.sound.samplerate, 44100)
        self.assertEqual(self.sound.bitrate, 0)
        self.assertEqual(self.sound.bitdepth, 0)  &#47&#47 This will be 0 because sound is mp3 and bitdepth is overwritten to 0
        &#47&#47 NOTE: after calling set_audio_info_fields processing will fail, but we&quotre only interested in testing up to
        &#47&#47 this point for the present unit test

    @mock.patch(&quotutils.audioprocessing.processing.convert_to_mp3&quot, side_effect=convert_to_mp3_mock_fail)
    @mock.patch(&quotutils.audioprocessing.processing.stereofy_and_find_info&quot, side_effect=stereofy_mock)
    @mock.patch(&quotutils.audioprocessing.processing.convert_to_pcm&quot, side_effect=convert_to_pcm_mock)
    @override_settings(USE_PREVIEWS_WHEN_ORIGINAL_FILES_MISSING=False)
    @override_processing_tmp_path_with_temp_directory
    @override_sounds_path_with_temp_directory
    @override_previews_path_with_temp_directory
    def test_make_mp3_previews_fails(self, *args):
        self.pre_test()
        result = FreesoundAudioProcessor(sound_id=Sound.objects.first().id).process()
        &#47&#47 processing will fail because convert_to_mp3 mock raises an exception
        self.assertFalse(result)  &#47&#47 Processing failed, retutned False
        self.sound.refresh_from_db()
        self.assertEqual(self.sound.processing_state, "FA")
        self.assertEqual(self.sound.processing_ongoing_state, "FI")
        self.assertIn(&quotconversion to mp3 (preview) has failed&quot, self.sound.processing_log)
        self.assertFalse(len(os.listdir(settings.PROCESSING_TEMP_DIR)), 0)

    @mock.patch(&quotutils.audioprocessing.processing.convert_to_ogg&quot, side_effect=convert_to_ogg_mock_fail)
    @mock.patch(&quotutils.audioprocessing.processing.convert_to_mp3&quot, side_effect=convert_to_mp3_mock)
    @mock.patch(&quotutils.audioprocessing.processing.stereofy_and_find_info&quot, side_effect=stereofy_mock)
    @mock.patch(&quotutils.audioprocessing.processing.convert_to_pcm&quot, side_effect=convert_to_pcm_mock)
    @override_settings(USE_PREVIEWS_WHEN_ORIGINAL_FILES_MISSING=False)
    @override_processing_tmp_path_with_temp_directory
    @override_sounds_path_with_temp_directory
    @override_previews_path_with_temp_directory
    def test_make_ogg_previews_fails(self, *args):
        self.pre_test()
        result = FreesoundAudioProcessor(sound_id=Sound.objects.first().id).process()
        &#47&#47 processing will fail because convert_to_ogg mock raises an exception
        self.assertFalse(result)  &#47&#47 Processing failed, retutned False
        self.sound.refresh_from_db()
        self.assertEqual(self.sound.processing_state, "FA")
        self.assertEqual(self.sound.processing_ongoing_state, "FI")
        self.assertIn(&quotconversion to ogg (preview) has failed&quot, self.sound.processing_log)
        self.assertFalse(len(os.listdir(settings.PROCESSING_TEMP_DIR)), 0)

    @mock.patch(&quotutils.audioprocessing.processing.create_wave_images&quot, side_effect=create_wave_images_mock_fail)
    @mock.patch(&quotutils.audioprocessing.processing.convert_to_ogg&quot, side_effect=convert_to_ogg_mock)
    @mock.patch(&quotutils.audioprocessing.processing.convert_to_mp3&quot, side_effect=convert_to_mp3_mock)
    @mock.patch(&quotutils.audioprocessing.processing.stereofy_and_find_info&quot, side_effect=stereofy_mock)
    @mock.patch(&quotutils.audioprocessing.processing.convert_to_pcm&quot, side_effect=convert_to_pcm_mock)
    @override_settings(USE_PREVIEWS_WHEN_ORIGINAL_FILES_MISSING=False)
    @override_processing_tmp_path_with_temp_directory
    @override_sounds_path_with_temp_directory
    @override_previews_path_with_temp_directory
    @override_displays_path_with_temp_directory
    def test_create_images_fails(self, *args):
        self.pre_test()
        result = FreesoundAudioProcessor(sound_id=Sound.objects.first().id).process()
        &#47&#47 processing will fail because create_wave_images mock raises an exception
        self.assertFalse(result)  &#47&#47 Processing failed, retutned False
        self.sound.refresh_from_db()
        self.assertEqual(self.sound.processing_state, "FA")
        self.assertEqual(self.sound.processing_ongoing_state, "FI")
        self.assertIn(&quotcreation of display images has failed&quot, self.sound.processing_log)
        self.assertFalse(len(os.listdir(settings.PROCESSING_TEMP_DIR)), 0)

    @mock.patch(&quotutils.audioprocessing.processing.create_wave_images&quot, side_effect=create_wave_images_mock)
    @mock.patch(&quotutils.audioprocessing.processing.convert_to_ogg&quot, side_effect=convert_to_ogg_mock)
    @mock.patch(&quotutils.audioprocessing.processing.convert_to_mp3&quot, side_effect=convert_to_mp3_mock)
    @mock.patch(&quotutils.audioprocessing.processing.stereofy_and_find_info&quot, side_effect=stereofy_mock)
    @mock.patch(&quotutils.audioprocessing.processing.convert_to_pcm&quot, side_effect=convert_to_pcm_mock)
    @override_settings(USE_PREVIEWS_WHEN_ORIGINAL_FILES_MISSING=False)
    @override_processing_tmp_path_with_temp_directory
    @override_sounds_path_with_temp_directory
    @override_previews_path_with_temp_directory
    @override_displays_path_with_temp_directory
    def test_skip_previews(self, *args):
        self.pre_test()
        result = FreesoundAudioProcessor(sound_id=Sound.objects.first().id)\
            .process(skip_previews=True)

        self.assertFalse(os.path.exists(self.sound.locations(&quotpreview.LQ.ogg.path&quot)))
        self.assertFalse(os.path.exists(self.sound.locations(&quotpreview.HQ.ogg.path&quot)))
        self.assertFalse(os.path.exists(self.sound.locations(&quotpreview.LQ.mp3.path&quot)))
        self.assertFalse(os.path.exists(self.sound.locations(&quotpreview.HQ.mp3.path&quot)))
        self.assertTrue(os.path.exists(self.sound.locations(&quotdisplay.spectral.M.path&quot)))
        self.assertTrue(os.path.exists(self.sound.locations(&quotdisplay.spectral_bw.M.path&quot)))
        self.assertTrue(os.path.exists(self.sound.locations(&quotdisplay.spectral.L.path&quot)))
        self.assertTrue(os.path.exists(self.sound.locations(&quotdisplay.spectral_bw.L.path&quot)))
        self.assertTrue(os.path.exists(self.sound.locations(&quotdisplay.wave.M.path&quot)))
        self.assertTrue(os.path.exists(self.sound.locations(&quotdisplay.wave_bw.M.path&quot)))
        self.assertTrue(os.path.exists(self.sound.locations(&quotdisplay.wave.L.path&quot)))
        self.assertTrue(os.path.exists(self.sound.locations(&quotdisplay.wave_bw.L.path&quot)))

        self.assertTrue(result)  &#47&#47 Processing succeeded
        self.sound.refresh_from_db()
        self.assertEqual(self.sound.processing_state, "OK")
        self.assertEqual(self.sound.processing_ongoing_state, "FI")
        self.assertFalse(len(os.listdir(settings.PROCESSING_TEMP_DIR)), 0)

    @mock.patch(&quotutils.audioprocessing.processing.create_wave_images&quot, side_effect=create_wave_images_mock)
    @mock.patch(&quotutils.audioprocessing.processing.convert_to_ogg&quot, side_effect=convert_to_ogg_mock)
    @mock.patch(&quotutils.audioprocessing.processing.convert_to_mp3&quot, side_effect=convert_to_mp3_mock)
    @mock.patch(&quotutils.audioprocessing.processing.stereofy_and_find_info&quot, side_effect=stereofy_mock)
    @mock.patch(&quotutils.audioprocessing.processing.convert_to_pcm&quot, side_effect=convert_to_pcm_mock)
    @override_settings(USE_PREVIEWS_WHEN_ORIGINAL_FILES_MISSING=False)
    @override_processing_tmp_path_with_temp_directory
    @override_sounds_path_with_temp_directory
    @override_previews_path_with_temp_directory
    @override_displays_path_with_temp_directory
    def test_skip_displays(self, *args):
        self.pre_test()
        result = FreesoundAudioProcessor(sound_id=Sound.objects.first().id) \
            .process(skip_displays=True)

        self.assertTrue(os.path.exists(self.sound.locations(&quotpreview.LQ.ogg.path&quot)))
        self.assertTrue(os.path.exists(self.sound.locations(&quotpreview.HQ.ogg.path&quot)))
        self.assertTrue(os.path.exists(self.sound.locations(&quotpreview.LQ.mp3.path&quot)))
        self.assertTrue(os.path.exists(self.sound.locations(&quotpreview.HQ.mp3.path&quot)))
        self.assertFalse(os.path.exists(self.sound.locations(&quotdisplay.spectral.M.path&quot)))
        self.assertFalse(os.path.exists(self.sound.locations(&quotdisplay.spectral_bw.M.path&quot)))
        self.assertFalse(os.path.exists(self.sound.locations(&quotdisplay.spectral.L.path&quot)))
        self.assertFalse(os.path.exists(self.sound.locations(&quotdisplay.spectral_bw.L.path&quot)))
        self.assertFalse(os.path.exists(self.sound.locations(&quotdisplay.wave.M.path&quot)))
        self.assertFalse(os.path.exists(self.sound.locations(&quotdisplay.wave_bw.M.path&quot)))
        self.assertFalse(os.path.exists(self.sound.locations(&quotdisplay.wave.L.path&quot)))
        self.assertFalse(os.path.exists(self.sound.locations(&quotdisplay.wave_bw.L.path&quot)))

        self.assertTrue(result)  &#47&#47 Processing succeeded
        self.sound.refresh_from_db()
        self.assertEqual(self.sound.processing_state, "OK")
        self.assertEqual(self.sound.processing_ongoing_state, "FI")
        self.assertFalse(len(os.listdir(settings.PROCESSING_TEMP_DIR)), 0)
</code></pre>