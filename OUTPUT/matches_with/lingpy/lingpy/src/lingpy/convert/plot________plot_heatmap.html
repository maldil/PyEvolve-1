<link rel="stylesheet" href="../../../../..//default.css">
<script src="../../../../..//highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><pre><code class='java'>
<a href="https://github.com/lingpy/lingpy/blob/master/src/lingpy/convert/plot.py#L872">GitHubLink</a>


<a href="https://github.com/maldil/lingpy/blob/master/src/lingpy/convert/plot.py#L872">GitMyHubLink</a>


Module provides functions for the transformation of text data into visually appealing
format.

from lingpy.settings import rcParams
from lingpy import log

import numpy as np
import networkx as nx
try:
    import matplotlib.pyplot as plt
    import matplotlib as mpl
except:
    log.missing_module(&quotmatplotlib&quot)
    plt, mpl = False, False

try:
    import scipy.cluster.hierarchy as sch
except:
    log.missing_module(&quotscipy&quot)
    sch = False

from lingpy.thirdparty import cogent as cg
from lingpy.convert.tree import nwk2tree_matrix
from lingpy.convert.graph import gls2gml, radial_layout

def plot_gls(
    gls,
    treestring,
    degree=90,
    fileformat=&quotpdf&quot,
    **keywords
):
    
    Plot a gain-loss scenario for a given reference tree.
    

    &#47&#47 get kewyords
    defaults = dict(
        figsize=(15, 15),
        left=0.05,
        top=0.95,
        bottom=0.05,
        right=0.95,
        radius=0.5,
        textsize=8,
        edgewidth=5,
        linewidth=2,
        scale_radius=1.2,
        ylim=1,
        xlim=1,
        text=True,
        gain_color=&quotwhite&quot,
        loss_color=&quotblack&quot,
        gain_linestyle=&quotdotted&quot,
        loss_linestyle=&quotsolid&quot,
        ax_linewidth=0,
        filename=rcParams[&quotfilename&quot]
    )

    for k in defaults:
        if k not in keywords:
            keywords[k] = defaults[k]

    &#47&#47 set filename as variabel for convenience
    filename = keywords[&quotfilename&quot]

    try:
        tree = cg.LoadTree(treestring=treestring)
    except:
        try:
            tree = cg.LoadTree(treestring)
        except:
            tree = treestring

    tgraph = radial_layout(treestring, degree=degree)

    graph = gls2gml(
        gls,
        tgraph,
        tree
    )

    nodes = []

    &#47&#47 assign nodes and edges
    for n, d in graph.nodes(data=True):
        g = d[&quotgraphics&quot]
        x = g[&quotx&quot]
        y = g[&quoty&quot]
        s = d[&quotstate&quot]

        nodes += [(x, y, s)]

    &#47&#47 now plot the stuff
    fig = plt.figure(figsize=keywords[&quotfigsize&quot])
    figsp = fig.add_subplot(111)
    figsp.axes.get_xaxis().set_visible(False)
    figsp.axes.get_yaxis().set_visible(False)

    &#47&#47 set the axes linewidht
    for s in figsp.spines.values():
        s.set_linewidth(keywords[&quotax_linewidth&quot])

    plt.axis(&quotequal&quot)

    for nA, nB in graph.edges():
        xA = graph.nodes[nA][&quotgraphics&quot][&quotx&quot]
        xB = graph.nodes[nB][&quotgraphics&quot][&quotx&quot]
        yA = graph.nodes[nA][&quotgraphics&quot][&quoty&quot]
        yB = graph.nodes[nB][&quotgraphics&quot][&quoty&quot]

        plt.plot(
            [xA, xB],
            [yA, yB],
            &quot-&quot,
            color=&quotblack&quot,
            linewidth=keywords[&quotedgewidth&quot],
            zorder=1
        )

    &#47&#47 now, iterate over nodes
    for x, y, s in nodes:
        if s == &quotO&quot:
            w = mpl.patches.Wedge(
                (x, y),
                keywords[&quotradius&quot],
                0, 360,
                facecolor=keywords[&quotgain_color&quot],
                linewidth=keywords[&quotlinewidth&quot],
                linestyle=keywords[&quotgain_linestyle&quot]
            )
        elif s == &quoto&quot:
            w = mpl.patches.Wedge(
                (x, y),
                keywords[&quotradius&quot] / keywords[&quotscale_radius&quot],
                0, 360,
                facecolor=keywords[&quotgain_color&quot],
                linewidth=keywords[&quotlinewidth&quot]
            )
        elif s == &quotL&quot:
            w = mpl.patches.Wedge(
                (x, y),
                keywords[&quotradius&quot],
                0, 360,
                facecolor=keywords[&quotloss_color&quot],
                linewidth=keywords[&quotlinewidth&quot],
                linestyle=keywords[&quotloss_linestyle&quot]
            )
        else:
            w = mpl.patches.Wedge(
                (x, y),
                keywords[&quotradius&quot] / keywords[&quotscale_radius&quot],
                0, 360,
                facecolor=keywords[&quotloss_color&quot],
                linewidth=keywords[&quotlinewidth&quot]
            )
        figsp.add_artist(w)

        &#47&#47 if text is chosen as argument
        if keywords[&quottext&quot]:
            if s in &quotOo&quot:
                t = &quot1&quot
                c = &quotblack&quot
            else:
                t = &quot0&quot
                c = &quotwhite&quot

            plt.text(
                x,
                y,
                t,
                size=keywords[&quottextsize&quot],
                color=c,
                va="center",
                ha="center",
                fontweight=&quotbold&quot
            )

    &#47&#47 set x and y-values
    xvals = [x[0] for x in nodes]
    yvals = [x[1] for x in nodes]

    plt.xlim(min(xvals) - keywords[&quotxlim&quot], max(xvals) + keywords[&quotxlim&quot])
    plt.ylim(min(yvals) - keywords[&quotylim&quot], max(yvals) + keywords[&quotylim&quot])

    plt.subplots_adjust(
        left=keywords[&quotleft&quot],
        right=keywords[&quotright&quot],
        top=keywords[&quottop&quot],
        bottom=keywords[&quotbottom&quot]
    )
    plt.savefig(
        filename + &quot.&quot + fileformat
    )
    plt.clf()
    log.file_written(filename + &quot.&quot + fileformat)


def plot_tree(
    treestring,
    degree=90,
    fileformat=&quotpdf&quot,
    root="root",
    **keywords
):
    
    Plot a Newick tree to PDF or other graphical formats.

    Parameters
    ----------
    treestring : str
        A string in Newick format.
    degree : int
        Determine the degree of the tree (this determines how "circular" the
        tree will be).
    fileformat : str (default="pdf")
        Select the fileformat to which the tree shall be written.
    filename : str
        Determine the name of the file to which the data shall be written.
        Defaults to a timestamp.
    figsize : tuple (default=(10,10))
        Determine the size of the figure.
    

    default = dict(
        ax_linewidth=0,
        bg=&quotblack&quot,
        bottom=0.05,
        change=lambda x: x ** 1.75,
        edge_list=[],
        figsize=(10, 10),
        filename=rcParams[&quotfilename&quot],
        fontweight=&quotbold&quot,
        frameon=False,
        ha=&quotcenter&quot,
        labels=[],
        left=0.05,
        linecolor=&quotblack&quot,
        linewidth=5,
        no_labels=False,
        node_dict={},
        nodecolor=&quotblack&quot,
        nodesize=10,
        right=0.95,
        start=0,
        textcolor=&quotwhite&quot,
        textsize=&quot10&quot,
        top=0.95,
        usetex=False,
        va=&quotcenter&quot,
        xlim=5,
        xliml=False,
        xlimr=False,
        ylim=5,
        ylimb=False,
        ylimt=False,
        rotation_mode=&quotanchor&quot,
        latex_preamble=False,
    )
    for k in default:
        if k not in keywords:
            keywords[k] = default[k]

    &#47&#47 set filename as variable for convenience
    filename = keywords[&quotfilename&quot]

    &#47&#47 switch backend, depending on whether tex is used or not
    backend = mpl.get_backend()
    if keywords[&quotusetex&quot] and backend != &quotpgf&quot:
        plt.switch_backend(&quotpgf&quot)
        mpl.rcParams[&quottext.latex.unicode&quot] = True
    elif not keywords[&quotusetex&quot] and backend != &quotTkAgg&quot:
        plt.switch_backend(&quotTkAgg&quot)

    if keywords[&quotlatex_preamble&quot]:
        mpl.rcParams[&quotpgf.preamble&quot] = keywords[&quotlatex_preamble&quot]

    &#47&#47 get the tree-graph
    graph = radial_layout(
        treestring,
        degree=degree,
        change=keywords[&quotchange&quot],
        start=keywords[&quotstart&quot],
        root=root
    )

    &#47&#47 create the figure
    fig = plt.figure(figsize=keywords[&quotfigsize&quot])
    figsp = fig.add_subplot(111)
    figsp.axes.get_xaxis().set_visible(False)
    figsp.axes.get_yaxis().set_visible(False)

    for s in figsp.spines.values():
        s.set_linewidth(keywords[&quotax_linewidth&quot])

    &#47&#47 plt.axes(frameon=keywords[&quotframeon&quot])
    plt.axis(&quotequal&quot)
    plt.xticks([])
    plt.yticks([])

    &#47&#47 get xlim and ylim
    xvals, yvals = [], []
    &#47&#47 start iterating over edges
    for nA, nB, d in list(graph.edges(data=True)) + keywords[&quotedge_list&quot]:

        &#47&#47 get the coordinates
        xA = graph.nodes[nA][&quotgraphics&quot][&quotx&quot]
        yA = graph.nodes[nA][&quotgraphics&quot][&quoty&quot]
        xB = graph.nodes[nB][&quotgraphics&quot][&quotx&quot]
        yB = graph.nodes[nB][&quotgraphics&quot][&quoty&quot]

        if &quotcolor&quot in d:
            plt.plot(
                [xA, xB],
                [yA, yB],
                &quot-&quot,
                **d
            )
        else:
            plt.plot(
                [xA, xB],
                [yA, yB],
                &quot-&quot,
                color=keywords[&quotlinecolor&quot],
                linewidth=keywords[&quotlinewidth&quot],
            )

    &#47&#47 get the nodes
    for n, d in graph.nodes(data=True):

        g = d[&quotgraphics&quot]
        x, y = g[&quotx&quot], g[&quoty&quot]

        xvals += [x]
        yvals += [y]

        &#47&#47 try to get information from the node-dict
        try:
            settings = {}
            settings.update(keywords[&quotnode_dict&quot][n])
        except:
            settings = {}

        &#47&#47 overwrite the stuff in keywords
        for k in keywords:
            if k not in settings:
                settings[k] = keywords[k]

        if d[&quotlabel&quot].startswith(&quotedge&quot) \
                or d[&quotlabel&quot].startswith(root) or keywords[&quotno_labels&quot]:
            plt.plot(
                x,
                y,
                &quoto&quot,
                markersize=settings[&quotnodesize&quot],
                color=settings[&quotnodecolor&quot],
                markeredgewidth=settings[&quotlinewidth&quot]
            )
        else:
            try:
                label = keywords[&quotlabels&quot][d[&quotlabel&quot]]
            except:
                label = d[&quotlabel&quot]
            if &quotrotation&quot in settings:
                r = settings[&quotrotation&quot]
            else:
                r = g[&quotangle&quot]
            plt.text(
                x,
                y,
                label,
                &#47&#47 d[&quotlabel&quot],
                color=settings[&quottextcolor&quot],
                fontweight=settings[&quotfontweight&quot],
                va=settings[&quotva&quot],
                ha=g[&quots&quot],
                bbox=dict(
                    facecolor=settings[&quotbg&quot],
                    boxstyle=&quotsquare,pad=0.2&quot,
                    ec="none",
                ),
                size=settings[&quottextsize&quot],
                rotation=r,  &#47&#47 g[&quotangle&quot],
                rotation_mode=settings[&quotrotation_mode&quot]
            )

    &#47&#47 set up the xlimits
    if not keywords[&quotxlimr&quot] and not keywords[&quotxliml&quot]:
        xl, xr = 2 * [keywords[&quotxlim&quot]]
    else:
        xl, xr = keywords[&quotxliml&quot], keywords[&quotxlimr&quot]

    &#47&#47 set up the xlimits
    if not keywords[&quotylimt&quot] and not keywords[&quotylimb&quot]:
        yb, yt = 2 * [keywords[&quotylim&quot]]
    else:
        yb, yt = keywords[&quotylimb&quot], keywords[&quotylimt&quot]

    plt.xlim((min(xvals) - xl, max(xvals) + xr))
    plt.ylim((min(yvals) - yb, max(yvals) + yt))

    plt.subplots_adjust(
        left=keywords[&quotleft&quot],
        right=keywords[&quotright&quot],
        top=keywords[&quottop&quot],
        bottom=keywords[&quotbottom&quot]
    )

    plt.savefig(filename + &quot.&quot + fileformat)
    plt.clf()
    log.file_written(filename + &quot.&quot + fileformat)


def plot_concept_evolution(
    scenarios,
    tree,
    fileformat=&quotpdf&quot,
    degree=90,
    **keywords
):
    
    Plot the evolution according to the MLN method of all words for a given concept.
    
    Parameters
    ----------
    tree : str
        A tree representation in Newick format.
    fileformat : str (default="pdf")
        A valid fileformat according to Matplotlib.
    degree : int (default=90)
        The degree by which the tree is drawn. 360 yields a circular tree, 180
        yields a tree filling half of the space of a circle.
    

    &#47&#47 make defaults
    defaults = dict(
        figsize=(15, 15),
        left=0.05,
        top=0.95,
        bottom=0.05,
        right=0.95,
        colormap=mpl.cm.jet,
        edgewidth=5,
        radius=2.5,
        outer_radius=0.5,
        inner_radius=0.25,
        cognates=&quot&quot,
        usetex=False,
        latex_preamble=False,
        textsize=8,
        change=lambda x: x ** 1.75,
        xlim=0,
        ylim=0,
        xlimr=False,
        xliml=False,
        ylimt=False,
        ylimb=False,
        rootsize=10,
        legend=True,
        legendsize=5,
        legendAloc=&quotupper right&quot,
        legendBloc=&quotlower right&quot,
        markeredgewidth=2.5,
        wedgeedgewidth=2,
        gain_linestyle=&quotdotted&quot,
        loss_linestyle=&quotsolid&quot,
        ax_linewidth=0,
        labels={},
        _prefix=&quot-   &quot,
        _suffix=&quot   -&quot,
        colors={},
        start=0,
        filename=rcParams[&quotfilename&quot],
        loss_alpha=0.1,
        loss_background=&quot0.75&quot,
        edges=[],
        hedge_color="black",
        hedge_width=5,
        hedge_linestyle=&quotdashed&quot,
    )
    keywords.update(defaults)

    &#47&#47 set filename as variable for convenience
    filename = keywords[&quotfilename&quot]

    &#47&#47 XXX customize later XXX
    colormap = keywords[&quotcolormap&quot]

    &#47&#47 switch backend, depending on whether tex is used or not
    backend = mpl.get_backend()
    if keywords[&quotusetex&quot] and backend != &quotpgf&quot:
        plt.switch_backend(&quotpgf&quot)
    elif not keywords[&quotusetex&quot] and backend != &quotTkAgg&quot:
        plt.switch_backend(&quotTkAgg&quot)

    &#47&#47 check for preamble settings
    if keywords[&quotlatex_preamble&quot]:
        mpl.rcParams[&quotpgf.preamble&quot] = keywords[&quotlatex_preamble&quot]

    &#47&#47 make a graph
    graph = nx.Graph()

    &#47&#47 get the tgraph
    tgraph = radial_layout(
        tree,
        degree=degree,
        change=keywords[&quotchange&quot],
        start=keywords[&quotstart&quot]
    )

    &#47&#47 get the taxa
    taxa = [n[0] for n in tgraph.nodes(data=True) if n[1][&quottip&quot]]

    &#47&#47 set the labels
    labels = {}
    for taxon in taxa:
        if taxon in keywords[&quotlabels&quot]:
            labels[taxon] = keywords[&quotlabels&quot][taxon]
        else:
            labels[taxon] = taxon

    &#47&#47 get the number of paps in order to get the right colors
    cfunc = np.array(np.linspace(10, 256, len(scenarios)), dtype=&quotint&quot)

    if not keywords[&quotcolors&quot]:
        colors = {scenarios[i][0]: mpl.colors.rgb2hex(colormap(cfunc[i]))
                  for i in range(len(scenarios))}
    else:
        colors = keywords[&quotcolors&quot]

    &#47&#47 get the wedges for the paps
    wedges = {}
    linsp = np.linspace(0, 360, len(scenarios) + 1)
    for i, scenario in enumerate(scenarios):
        pap = scenario[0]
        theta1, theta2 = linsp[i], linsp[i + 1]
        wedges[pap] = (theta1, theta2)

    if keywords[&quotlegend&quot]:

        &#47&#47 set the linestyle for the legend
        if keywords[&quotgain_linestyle&quot] == &quotdotted&quot:
            ls = &quot:&quot
        elif keywords[&quotgain_linestyle&quot] == &quotdashed&quot:
            ls = &quot--&quot

        legendEntriesA = []
        legendTextA = []

        &#47&#47 add stuff for the legend
        for pap, gls in scenarios:
            w = mpl.patches.Wedge(
                (0, 0),
                1,
                wedges[pap][0],
                wedges[pap][1],
                facecolor=colors[pap],
                zorder=1,
                linewidth=keywords[&quotwedgeedgewidth&quot],
                edgecolor=&quotblack&quot
            )
            legendEntriesA += [w]
            legendTextA += [pap]

        &#47&#47 second legend explains evolution
        legendEntriesB = []
        legendTextB = []
        p = mpl.patches.Wedge(
            (0, 0),
            1,
            0,
            360,
            facecolor=&quot0.5&quot,
            linewidth=keywords[&quotwedgeedgewidth&quot],
            edgecolor=&quotblack&quot,
        )
        legendEntriesB += [p]
        legendTextB += [&quotLoss Event&quot]
        p, = plt.plot(
            0, 0,
            ls,
            color=&quotblack&quot,
            linewidth=keywords[&quotwedgeedgewidth&quot]
        )
        legendEntriesB += [p]
        legendTextB += [&quotGain Event&quot]

        &#47&#47 overwrite stuff
        plt.plot(0, 0, &quoto&quot, markersize=2, zorder=2, color=&quotwhite&quot)

    &#47&#47 iterate over the paps and append states to the graph
    for pap, gls in scenarios:

        &#47&#47 get the graph with the model
        g = gls2gml(
            gls,
            tgraph,
            tree,
            filename=&quot&quot
        )

        &#47&#47 iterate over the graph
        for n, d in g.nodes(data=True):

            &#47&#47 add the node if necessary
            if n not in graph:
                graph.add_node(n)

            &#47&#47 add a pap-dictionary if it&quots not already there
            if &quotpap&quot not in graph.nodes[n]:
                graph.nodes[n][&quotpap&quot] = {}

            &#47&#47 add data
            graph.nodes[n][&quotpap&quot][pap] = d[&quotstate&quot]

    &#47&#47 create the figure
    fig = plt.figure(figsize=keywords[&quotfigsize&quot])
    figsp = fig.add_subplot(111)
    figsp.axes.get_xaxis().set_visible(False)
    figsp.axes.get_yaxis().set_visible(False)

    for s in figsp.spines.values():
        s.set_linewidth(keywords[&quotax_linewidth&quot])

    plt.axis(&quotequal&quot)

    xvals = []
    yvals = []

    &#47&#47 iterate over edges first
    for nA, nB in g.edges():
        gA = g.nodes[nA][&quotgraphics&quot]
        gB = g.nodes[nB][&quotgraphics&quot]
        xA, yA = gA[&quotx&quot], gA[&quoty&quot]
        xB, yB = gB[&quotx&quot], gB[&quoty&quot]

        plt.plot(
            [xA, xB],
            [yA, yB],
            &quot-&quot,
            color=&quotblack&quot,
            linewidth=keywords[&quotedgewidth&quot]
        )

    &#47&#47 add horizontal edges if this option is chosen
    if keywords[&quotedges&quot]:
        &#47&#47 get the coordinates
        for nA, nB in keywords[&quotedges&quot]:
            gA = g.nodes[nA][&quotgraphics&quot]
            gB = g.nodes[nB][&quotgraphics&quot]
            xA, yA = gA[&quotx&quot], gA[&quoty&quot]
            xB, yB = gB[&quotx&quot], gB[&quoty&quot]

            plt.plot(
                [xA, xB],
                [yA, yB],
                &quot-&quot,
                color=keywords[&quothedge_color&quot],
                linewidth=keywords["hedge_width"],
                linestyle=keywords[&quothedge_linestyle&quot]
            )

    &#47&#47 now iterate over the nodes
    for n, d in graph.nodes(data=True):
        cpaps = d[&quotpap&quot]
        x, y = g.nodes[n][&quotgraphics&quot][&quotx&quot], g.nodes[n][&quotgraphics&quot][&quoty&quot]

        &#47&#47 get z-value which serves as zorder attribute
        try:
            z = 6 * len(tree.getConnectingEdges(&quotroot&quot, n))
        except:
            z = 0

        xvals += [x]
        yvals += [y]

        &#47&#47 plot the default marker
        plt.plot(
            x,
            y,
            &quoto&quot,
            markersize=keywords[&quotrootsize&quot],
            color=&quotblack&quot,
            zorder=50
        )
        &#47&#47 check for origins in cpaps
        if &quotO&quot in cpaps.values():
            w = mpl.patches.Wedge(
                (x, y),
                keywords[&quotradius&quot] + keywords[&quotouter_radius&quot],
                0,
                360,
                facecolor=&quotwhite&quot,
                zorder=57 + z,
                linewidth=keywords[&quotmarkeredgewidth&quot],
                linestyle=keywords[&quotgain_linestyle&quot],
            )
            figsp.add_artist(w)
        &#47&#47 check for retentions
        elif &quoto&quot in cpaps.values():
            w = mpl.patches.Wedge(
                (x, y),
                keywords[&quotradius&quot] + keywords[&quotouter_radius&quot],
                0,
                360,
                facecolor=&quotwhite&quot,
                zorder=56 + z,
                linewidth=keywords[&quotmarkeredgewidth&quot],
                linestyle=&quotsolid&quot,
            )
            figsp.add_artist(w)

        if &quotL&quot in cpaps.values() and &quotO&quot in cpaps.values():
            w = mpl.patches.Wedge(
                (x, y),
                keywords[&quotradius&quot] + keywords[&quotouter_radius&quot],
                0,
                360,
                facecolor=keywords[&quotloss_background&quot],
                zorder=58 + z,
                linewidth=keywords[&quotmarkeredgewidth&quot],
                edgecolor=&quotblack&quot,
                linestyle=keywords[&quotloss_linestyle&quot]
            )
            figsp.add_artist(w)

        elif "L" in cpaps.values():
            w = mpl.patches.Wedge(
                (x, y),
                keywords[&quotradius&quot] + keywords[&quotouter_radius&quot],
                0,
                360,
                facecolor=keywords[&quotloss_background&quot],
                zorder=59 + z,
                linewidth=keywords[&quotmarkeredgewidth&quot],
                edgecolor=&quotblack&quot,
            )
            figsp.add_artist(w)

        &#47&#47 plot all wedges
        for pap in cpaps:

            theta1, theta2 = wedges[pap]
            color = colors[pap]

            &#47&#47 check for characteristics of this pap

            &#47&#47 if it&quots a loss
            if cpaps[pap] == &quotL&quot:

                w = mpl.patches.Wedge(
                    (x, y),
                    keywords[&quotradius&quot],
                    theta1,
                    theta2,
                    facecolor=color,
                    zorder=61 + z,
                    alpha=keywords[&quotloss_alpha&quot],  &#47&#47 0.25,
                    linewidth=keywords[&quotwedgeedgewidth&quot],
                    edgecolor=&quotblack&quot,
                    linestyle=keywords[&quotloss_linestyle&quot]
                )
                figsp.add_artist(w)

            elif cpaps[pap] == &quoto&quot:

                w = mpl.patches.Wedge(
                    (x, y),
                    keywords[&quotradius&quot],
                    theta1,
                    theta2,
                    facecolor=color,
                    zorder=61 + z,
                    linewidth=keywords[&quotwedgeedgewidth&quot],
                    edgecolor=&quotblack&quot
                )
                figsp.add_artist(w)

            elif cpaps[pap] == &quotO&quot:

                w = mpl.patches.Wedge(
                    (x, y),
                    keywords[&quotradius&quot],
                    theta1,
                    theta2,
                    facecolor=color,
                    zorder=61 + z,
                    linewidth=keywords[&quotwedgeedgewidth&quot],
                    edgecolor=&quotblack&quot,
                    linestyle=keywords[&quotgain_linestyle&quot]
                )
                figsp.add_artist(w)

                &#47&#47 add the labels if this option is chosen
        if keywords[&quotlabels&quot]:
            &#47&#47 if node is a tip
            if tgraph.nodes[n][&quottip&quot]:

                &#47&#47 get the values
                gf = tgraph.nodes[n][&quotgraphics&quot]
                r = gf[&quotangle&quot]
                x, y = gf[&quotx&quot], gf[&quoty&quot]
                ha = gf[&quots&quot]

                &#47&#47 modify the text
                if ha == &quotleft&quot:
                    text = keywords[&quot_prefix&quot] + labels[n]
                else:
                    text = labels[n] + keywords[&quot_suffix&quot]

                &#47&#47 plot the text
                plt.text(
                    x,
                    y,
                    text,
                    size=keywords[&quottextsize&quot],
                    va=&quotcenter&quot,
                    ha=ha,
                    fontweight=&quotbold&quot,
                    color=&quotblack&quot,
                    rotation=r,
                    rotation_mode=&quotanchor&quot,
                    zorder=z
                )

    &#47&#47 set up the xlimits
    if not keywords[&quotxlimr&quot] and not keywords[&quotxliml&quot]:
        xl, xr = 2 * [keywords[&quotxlim&quot]]
    else:
        xl, xr = keywords[&quotxliml&quot], keywords[&quotxlimr&quot]

    &#47&#47 set up the xlimits
    if not keywords[&quotylimt&quot] and not keywords[&quotylimb&quot]:
        yb, yt = 2 * [keywords[&quotylim&quot]]
    else:
        yb, yt = keywords[&quotylimb&quot], keywords[&quotylimt&quot]

    plt.xlim((min(xvals) - xl, max(xvals) + xr))
    plt.ylim((min(yvals) - yb, max(yvals) + yt))

    prop = mpl.font_manager.FontProperties(size=keywords[&quotlegendsize&quot])

    if keywords[&quotlegend&quot]:
        legend1 = plt.legend(
            legendEntriesA,
            legendTextA,
            loc=keywords[&quotlegendAloc&quot],
            numpoints=1,
            prop=prop
        )
        plt.legend(
            legendEntriesB,
            legendTextB,
            loc=keywords[&quotlegendBloc&quot],
            prop=prop
        )
        figsp.add_artist(legend1)

    plt.subplots_adjust(
        left=keywords[&quotleft&quot],
        right=keywords[&quotright&quot],
        top=keywords[&quottop&quot],
        bottom=keywords[&quotbottom&quot]
    )

    plt.savefig(filename + &quot.&quot + fileformat)
    plt.clf()
    log.file_written(filename + &quot.&quot + fileformat)


def plot_heatmap(
    wordlist,
    filename="heatmap",
    fileformat="pdf",
    ref=&quotcogid&quot,
    normalized=False,
    refB=&quot&quot,
    **keywords
):
    
    Create a heatmap-representation of shared cognates for a given wordlist.

    Parameters
    ----------
    wordlist : lingpy.basic.wordlist.Wordlist
        A Wordlist object containing cognate IDs.
    filename : str (default="heatmap")
        Name of the file to which the heatmap will be written.
    fileformat : str (default="pdf")
        A regular matplotlib-fileformat (pdf, png, pgf, svg).
    ref : str (default="cogid&quot)
        The name of the column that contains the cognate identifiers.
    normalized : {bool str} (default=True)
        If set to c{False}, don&quott normalize the data. Otherwise, select the
        normalization method, choose between:
        
        * "jaccard" for the Jaccard-distance (see :evobib:`Bategelj1995` for
          details), and
        * "swadesh" for traditional lexicostatistical calculation of shared
          cognate percentages.

    cmap : matplotlib.cm (default=matplotlib.cm.jet)
        The color scheme to be used for the heatmap.
    steps : int (default=5)
        The number of steps in which names of taxa will be written to the axes.
    xrotation : int (default=45)
        The rotation of the taxon-names on the x-axis.
    colorbar : bool (default=True)
        Specify, whether a colorbar should be added to the plot.
    figsize : tuple (default=(10,10))
        Specify the size of the figure.
    tree : str (default=&quot&quot)
        A tree passed for the taxa in Newick-format. If no tree is specified,
        the method looks for a tree object in the Wordlist.

    Notes
    -----
    This function plots shared cognate percentages.

    
    defaults = dict(
        bottom=0.01,  &#47&#47 rcParams[&quotphybo_ylimb&quot]
        cmap=mpl.cm.jet,
        colorbar=True,
        colorbar_label="Shared Cognates",
        colorbar_shrink=0.75,
        colorbar_textsize=10,
        figsize=(10, 5),
        height=0.8,
        labels={},  &#47&#47 taxon labels passed for the taxa,
        left=0.01,  &#47&#47 rcParams[&quotphybo_xlimr&quot],
        matrix=False,
        normalization="jaccard",
        right=0.95,  &#47&#47 rcParams[&quotphybo_xliml&quot],
        scale=0.075,
        show_tree=True,
        steps=20,
        textsize=5,
        top=0.95,  &#47&#47 rcParams[&quotphybo_ylimt&quot],
        tree=&quot&quot,
        tree_bottom=0.1,
        tree_left=0.1,
        tree_width=0.2,
        vmax=1.0,
        vmin=0.0,
        width=0.8,
        xrotation=90,
        distances=False
    )
    for k in defaults:
        if k not in keywords:
            keywords[k] = defaults[k]

    &#47&#47 access the reference tree of the wordlist and create a function that
    &#47&#47 orders the taxa accordingly
    if not keywords[&quottree&quot]:
        try:
            tree = wordlist.tree
        except:
            raise ValueError("[i] No tree could be found")
    else:
        tree = keywords["tree"]

    &#47&#47 check for normalization
    if normalized:
        if normalized not in ["jaccard", "swadesh"]:
            raise ValueError(
                "Keyword &quotnormalized&quot must be one of &quotjaccard&quot,&quotswadesh&quot,False.")

    &#47&#47 create an empty matrix
    if not normalized:
        matrix = np.zeros((wordlist.width, wordlist.width), dtype=int)
    else:
        matrix = np.zeros((wordlist.width, wordlist.width), dtype=float)

    &#47&#47 create the figure
    fig = plt.figure(figsize=keywords[&quotfigsize&quot])

    &#47&#47 plot the reference tree
    if keywords[&quotshow_tree&quot]:
        tree_matrix, taxa_in_matrix = nwk2tree_matrix(tree)
        ax1 = <a id="change">fig</a>.add_axes(
            [
                keywords[&quotleft&quot],
                keywords[&quotbottom&quot],
                0.25 * keywords[&quotwidth&quot],
                keywords[&quotheight&quot]
            ]
        )
        &#47&#47 [0.01,0.1,0.2,0.7])
        d = sch.dendrogram(
            np.array(tree_matrix),
            labels=[t for t in taxa_in_matrix],
            orientation=&quotleft&quot,

        )
        taxa = d[&quotivl&quot][::-1]
        <a id="change">ax1</a>.set_xticks([])
        <a id="change">ax1</a>.set_yticks([])
        ax1.spines[&quotbottom&quot].set_color(&quot&#47&#47ffffff&quot)
        ax1.spines[&quottop&quot].set_color(&quot&#47&#47ffffff&quot)
        ax1.spines[&quotleft&quot].set_color(&quot&#47&#47ffffff&quot)
        ax1.spines[&quotright&quot].set_color(&quot&#47&#47ffffff&quot)
        left = keywords[&quotleft&quot] + keywords[&quotscale&quot] * keywords[&quotwidth&quot]

    else:
        left = keywords[&quotleft&quot]
        taxa = tree.taxa
        taxa_in_matrix = taxa

    &#47&#47 start iterating over taxa in order of the reference tree and fill in the
    &#47&#47 matrix with numbers of shared cognates
    if keywords[&quotmatrix&quot]:
        matrix = [[cell for cell in row] for row in keywords[&quotmatrix&quot]]
        conv = {}
        for i, taxon in enumerate(taxa):
            conv[i] = taxa_in_matrix.index(taxon)
        for i, taxonA in enumerate(taxa):
            for j, taxonB in enumerate(taxa):
                matrix[i][j] = keywords["matrix"][conv[i]][conv[j]]
    else:
        for i, taxonA in enumerate(taxa):
            for j, taxonB in enumerate(taxa):
                if i &lt; j:
                    if normalized in [False, "jaccard"]:
                        cogsA = wordlist.get_list(
                            taxa=taxonA,
                            flat=True,
                            entry=ref
                        )
                        cogsB = wordlist.get_list(
                            taxa=taxonB,
                            flat=True,
                            entry=ref
                        )

                        cogsA, cogsB = set(cogsA), set(cogsB)

                        shared = len(<a id="change">cogsA</a>.intersection(cogsB))

                        if normalized:
                            shared = shared / len(<a id="change">cogsA</a>.union(cogsB))
                    else:
                        cogsA = wordlist.get_dict(
                            taxa=taxonA,
                            entry=ref
                        )
                        cogsB = wordlist.get_dict(
                            taxa=taxonB,
                            entry=ref
                        )

                        shared = 0
                        slots = 0

                        &#47&#47 iterate over cognate sets in meaning slots
                        for key in <a id="change">cogsA</a>.keys():
                            &#47&#47 check whether keys are present, we follow the
                            &#47&#47 STARLING procedure in ignoring missing data
                            if key in cogsA and key in cogsB:

                                &#47&#47 check for shared items
                                if [k for k in cogsA[key] if k in cogsB[key]]:
                                    shared += 1
                                slots += 1
                        try:
                            shared = shared / slots
                        except ZeroDivisionError:
                            log.warning(str(
                                [shared, slots, len(cogsA), len(cogsB), taxonA, taxonB]))
                            shared = 0.0

                    matrix[i][j] = shared

                    &#47&#47 if refB is also a possibiltiy
                    if not refB:
                        matrix[j][i] = shared

                elif i &gt; j and refB:
                    if normalized in [False, "jaccard"]:
                        cogsA = wordlist.get_list(
                            taxa=taxonA,
                            flat=True,
                            entry=refB
                        )
                        cogsB = wordlist.get_list(
                            taxa=taxonB,
                            flat=True,
                            entry=refB
                        )

                        cogsA, cogsB = set(cogsA), set(cogsB)

                        shared = len(<a id="change">cogsA</a>.intersection(cogsB))

                        if normalized:
                            shared = shared / len(<a id="change">cogsA</a>.union(cogsB))
                    else:
                        cogsA = wordlist.get_dict(
                            taxa=taxonA,
                            entry=refB
                        )
                        cogsB = wordlist.get_dict(
                            taxa=taxonB,
                            entry=refB
                        )

                        shared = 0
                        slots = 0

                        &#47&#47 iterate over cognate sets in meaning slots
                        for key in <a id="change">cogsA</a>.keys():
                            &#47&#47 check whether keys are present, we follow the
                            &#47&#47 STARLING procedure in ignoring missing data
                            if key in cogsA and key in cogsB:

                                &#47&#47 check for shared items
                                if [k for k in cogsA[key] if k in cogsB[key]]:
                                    shared += 1
                                slots += 1
                        try:
                            shared = shared / slots
                        except ZeroDivisionError:
                            log.warning(str(
                                [shared, slots, len(cogsA), len(cogsB), taxonA, taxonB]))
                            shared = 0.0

                    matrix[i][j] = shared

                elif i == j:
                    cogs = wordlist.get_list(
                        taxa=taxonA,
                        flat=True,
                        entry=ref
                    )
                    if normalized:
                        matrix[i][j] = 1.0
                    else:
                        matrix[i][j] = len(set(cogs))
    ax2 = <a id="change">fig</a>.add_axes(
        [
            left,  &#47&#47 keywords[&quotleft&quot]+0.25 * keywords[&quotwidth&quot]+0.05,
            keywords[&quotbottom&quot],
            keywords[&quotwidth&quot],
            keywords[&quotheight&quot]
        ]
    )
    cmap = keywords[&quotcmap&quot] 

    &#47&#47 [0.15,0.1,0.7,0.7])
    if &quotdistances&quot in keywords and keywords[&quotdistances&quot]:
        for i, line in enumerate(matrix):
            for j, cell in enumerate(matrix):
                matrix[i][j] = 1 - matrix[i][j]
    nmatrix = [
            [keywords[&quotvmax&quot], keywords[&quotvmin&quot]],
            [keywords[&quotvmin&quot], keywords[&quotvmax&quot]]
            ]

    im = <a id="change">ax2</a>.matshow(nmatrix, aspect=&quotauto&quot, origin=&quotlower&quot,
                     interpolation=&quotnearest&quot, cmap=keywords[&quotcmap&quot],
                     vmax=keywords[&quotvmax&quot], vmin=keywords[&quotvmin&quot]
                     )

    &#47&#47 set the xticks
    steps = int(len(taxa) / keywords[&quotsteps&quot] + 0.5)
    start = int(steps / 2 + 0.5)
    idxs = [0] + list(range(start, len(taxa), steps))
    selected_taxa = [taxa[i] for i in idxs]

    &#47&#47 modify taxon names if this is specified
    for i, t in enumerate(selected_taxa):
        if t in keywords[&quotlabels&quot]:
            selected_taxa[i] = keywords[&quotlabels&quot][t]

    <a id="change">ax2</a>.set_xticks([])
    <a id="change">ax2</a>.set_yticks([])



    plt.xticks(
        idxs,
        selected_taxa,
        size=keywords[&quottextsize&quot],
        rotation=keywords[&quotxrotation&quot],
        rotation_mode="default"
    )
    plt.yticks(
        idxs,
        selected_taxa,
        size=keywords[&quottextsize&quot],
    )

    if keywords["colorbar"]:

        plt.imshow(matrix, cmap=keywords[&quotcmap&quot], visible=False, vmax=keywords[&quotvmax&quot])
        c = plt.colorbar(im, shrink=keywords[&quotcolorbar_shrink&quot])
        <a id="change">c</a>.set_label(keywords["colorbar_label"], size=keywords[&quotcolorbar_textsize&quot])

    plt.subplots_adjust(
        left=keywords[&quotleft&quot],
        right=keywords[&quotright&quot],
        top=keywords[&quottop&quot],
        bottom=keywords[&quotbottom&quot]
    )
    plt.savefig(filename + &quot.&quot + fileformat)

    <a id="change">f</a><a id="change"> = open(filename + &quot.matrix&quot, &quotw&quot)</a>
    for i, t in enumerate(taxa):
        <a id="change">f</a>.write(&quot{0:20}&quot.format(t))
        for j, c in enumerate(matrix[i]):
            if not normalized:
                <a id="change">f</a>.write(&quot\t{0:3}&quot.format(int(c)))
            else:
                <a id="change">f</a>.write(&quot\t{0:.2f}&quot.format(c))
        <a id="change">f</a>.write(&quot\n&quot)
    <a id="change">f</a><a id="change">.close()</a>
    log.file_written(filename + &quot.&quot + fileformat)
</code></pre>